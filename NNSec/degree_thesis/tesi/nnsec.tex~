\chapter{NNSec}\label{cap:two}
\epigraph{Se ascolto dimentico, se osservo ricordo, se faccio imparo}{Baden Powell}

NNSec, o Neural Network Secure, è un applicativo scritto totalmente in Java che implementa il protocollo precedentemente descritto, lasciando all'utente diversi gradi di libertà nella configurazione lato server.

Nello sviluppo di NNSec sono state introdotte molte tecniche prese in prestito dai più svariati ambiti della programmazione, come ad esempio metodologie mirate per la gestione dell'accesso concorrente (spesso presenti nell'ambito dei sistemi operativi) applicate alla singola rete neurale, o pattern di progettazione tipici dell'ingegneria del software come il pattern factory o il pattern composite, utilizzati per risolvere in modo elegante e pulito alcuni problemi cruciali del progetto.

Basandosi interamente su Java, NNSec fa uso e abuso di molti degli strumenti che questo linguaggio offre allo sviluppatore. In particolare, come sarà illustrato e discusso in seguito, articola gran parte della sua struttura su RMI (o Remote Method Invocation) e si appoggia alle Java Swing per poter fornire una GUI piacevole ed efficace all'utente finale. Ciò nonostante, sono stati usati anche strumenti esterni non direttamente forniti insieme alla libreria standard di Java, come ad esempio un tool per la progettazione, lo sviluppo e la creazione di un parser in modo automatico.

Il risultato finale del lavoro di tesi è rappresentato proprio dal programma NNSec, ovvero dalla realizzazione di uno strumento che permettesse di toccare con mano il protocollo proposto e fino ad oggi discusso solamente in linea teorica. Pertanto, data l'importanza non trascurabile dei dettagli tecnici che stanno dietro al cosa e permettono di capire il come, saranno discussi in questo capitolo i principi di progettazione e le linee guida adottate durante la realizzazione del software.

\newpage

\section{Progettazione e Struttura}\label{sec:ps}
\begin{figure}
\centering
\includegraphics[scale=0.60,angle=90]{img/classdiag.eps}
\caption{\figfont diagramma delle classi (semplificato)}\label{fig:cdiag}
\end{figure}
NNSec nasce come implementazione del protocollo descritto nel capitolo precedente, con lo scopo di trasformarlo in qualcosa di concreto su cui poter effettuare i primi esperimenti e da utilizzare come base per sviluppi futuri. NNSec rappresenta, quindi, un banco di prova per la crittografia in questo ambito da cui poter attingere così da ricavare dati importanti per valutazioni e progetti in questa direzione.

Va detto fin da subito che proprio nel tentativo di rendere agevoli modifiche, estensioni o studi a posteriori del software, tutti i file sono stati documentati con commenti estraibili in formato html tramite l'uso di javadoc. Inoltre, l'insieme delle classi è stato progettato in modo da poter rendere non traumatiche eventuali variazioni nel codice, così da non dover costringere alla modifica di tutti i file per poter cambiare anche di poco un algoritmo o una interfaccia a causa di dipendenze pesanti.\\
La struttura di NNSec, seppure non esagerata in numero di classi, risulta abbastanza complessa in quanto sono state introdotte alcune metodologie proprie dell'ingegneria del software, come il pattern singleton ma non solo, sono state sfruttate alcune tecniche particolari messe a disposizione dal linguaggio Java, come le classi interne e il loro retro-riferimento verso l'esterno, e sono state ampiamente utilizzate tecnologie specifiche di questo linguaggio e della sua libreria, come RMI, che rendono più ostica la comprensione delle relazioni fra gli oggetti e la stesura di un diagramma delle classi che sia al tempo stesso completo e chiaro. Una versione semplificata di quest'ultimo è comunque riportata in figura \ref{fig:cdiag}.

I principi adottati durante l'intera ideazione delle classi sono quelli del disaccoppiamento fra di esse (così da abbattere le inter-relazioni che si possono venire a creare fra oggetti altrimenti indipendenti) e la divisione dei compiti in componenti elementari. Nello specifico, ogni classe è stata creata tenendo salda in mente la regola base della programmazione, anche detta KISS\footnote{Keep It Simple, Stupid (Rendilo semplice, banale)}: questo principio invita a non progettare pensando fin da subito alle possibili ottimizzazioni applicabili in un punto piuttosto che un altro, ma cercando di mantenere uno stile di programmazione che miri alla semplicità ed eviti la complessità, lasciando eventuali ottimizzazioni al compilatore o alle successive fasi di sviluppo. Questo ha portato ad un insieme di classi forse più ampio del necessario ma in cui ognuna è rappresentata da poche centinaia di righe di codice (ben documentato nei particolari), in alcuni casi addirittura solo alcune decine. Classi semplici, quindi, ma funzionali, ognuna relegata a svolgere un compito preciso, ben definito e senza doversi caricare di un numero esagerato di operazioni.\\
Per quanto riguarda le relazioni fra classi diverse, queste sono state mantenute al minimo cercando di creare dei punti di accesso specifici su cui ognuna potesse contare per l'interazione con le altre. Tutto ciò, ovviamente, rappresenta una specie di contratto che il programmatore non dovrà infrangere neanche al momento in cui si troverà a dover stravolgere completamente la struttura interna di una delle classi coinvolte. Basterà, pertanto, lasciare intatti i punti di contatto che queste offrono verso l'esterno ed eventuali modifiche non si ripercuoteranno in alcun modo verso l'esterno.\\
Un discorso simile a quanto appena esposto è applicabile anche alle interfacce, ampiamente usate soprattutto a causa della forzatura imposta dall'uso di RMI che obbliga ad appoggiare ogni classe su una specifica interfaccia (che sarà, poi, quella esportata remotamente). Nella progettazione di queste interfacce si è cercato di definire in modo chiaro e completo il numero e il prototipo dei metodi esposti, in quanto questi rappresentano anche le possibili chiamate effettuabili da parte di oggetti remoti. Vale la stessa osservazione fatta anche in precedenza: queste interfacce rappresentano un accordo fra chi espone i metodi e chi tali metodi li sfrutta. Stravolgere la loro struttura significherebbe costringere alla re-implementazione di un gran numero di classi, cosa solitamente non troppo gradita. Anche per questo è stata riposta un'attenzione particolare nella progettazione delle interfacce remote, così da lasciare ampio spazio ad una totale riscrittura dei metodi nel caso in cui nuovi algoritmi prendano il posto degli attuali ma senza che questo comporti un terremoto all'interno del codice con conseguente modifica di gran parte di esso.
\paragraph{}
Alcune note vanno fatte sul risultato finale, ovvero il software NNSec.\\
A seguito di svariate scelte di progetto a monte della fase di sviluppo e in corso d'opera, NNSec gode di alcune caratteristiche particolari non necessarie ma senza ombra di dubbio desiderabili:
\begin{itemize}
\item la componente server NNSec supporta l'interazione con più client contemporaneamente, riuscendo a servire più richieste in modo concorrente e regolando l'accesso alle risorse per un corretto uso di quest'ultime che garantisca l'integrità dei dati
\item all'interno di NNSec sia i percettroni che le reti neurali multi-livello feed-forward sono rappresentate astraendo dal loro tipo effettivo, permettendo la memorizzazione e gestione con funzioni e  strutture dati generiche e non specifiche a seconda della tipologia di oggetto
\item gli algoritmi proposti in linea teorica nel protocollo (si veda a tale proposito sezione \ref{sec:proto}) sono stati uniformati in un unico algoritmo capace di interagire e trattare correttamente sia percettroni che reti neurali multi-livello feed-forward
\end{itemize}
Il tutto sfocia in un programma più semplice e più efficiente in grado di gestire l'accesso concorrente alle risorse (ovvero, alle reti neurali messe a disposizione per l'uso remoto), tanto facile da gestire quanto da capire e che generalizza in molti punti anziché articolarsi in rami diversi facendo distinzioni a monte sugli elementi trattati.

\section{NNSec}
Fedele alle linee guida di Java, anche NNSec è stato progettato assegnando ogni singola classe ad un package appropriato e suddividendo il progetto in un insieme articolato ma coerente di subpackage, così da permettere a chi fosse interessato di orientarsi senza difficoltà fra le classi coinvolte.

L'insieme delle classi componenti NNSec è stato partizionato in cinque gruppi principali, ovvero le classi che compongono il parser, il cifrario, tutti gli elementi coinvolti nella realizzazione e gestione delle reti neurali, le classi lato server e quelle lato client, rispettivamente appartenenti ai subpackage \texttt{parser}, \texttt{cryptosystem}, \texttt{net}, \texttt{server} e \texttt{client}. Questa suddivisione è stata utile anche per separare in linea teorica le classi fra loro, in modo da poter attribuire velocemente un ruolo univoco in uno specifico ambiente ad ognuna di esse. Ciò nonostante, per motivi dovuti tanto all'uso di RMI quanto alla struttura del protocollo, la componente server si avvale anche di classi e interfacce presenti in \texttt{nnsec.client}, così come la componente client si affida a classi e interfacce in \texttt{nnsec.server}; entrambe, inoltre, attingono da tutti gli altri sotto pacchetti presenti nel package \texttt{nnsec}. La suddivisione, pertanto, sebbene marcata in modo netto nasconde fra le righe relazioni inter-pacchetto che rendono l'insieme delle classi e delle interfacce un'entità unica ben amalgamata.\\
Il package \texttt{nnsec} rappresenta il package principale del progetto. In realtà, questo package è fittizio e non contiene classi ma fa da involucro per i subpackage sopra elencati, raccogliendoli in un insieme unico. Non è pertanto di particolare interesse e non sarà discusso ulteriormente.

\section{Parser}
Il subpackage \texttt{parser} è il package che contiene le classi relative all'interprete dei file di ingresso per la descrizione delle reti neurali in NNSec.

Il ruolo del parser risulta essere abbastanza importante anche se non direttamente coinvolto nell'implementazione del protocollo proposto. Infatti, il protocollo tratta l'uso di reti neurali remote in sicurezza e queste, in un modo o nell'altro, devono essere create e addestrate ma soprattutto rese disponibili dentro a NNSec, lato server. In quest'ottica entra in gioco il parser e un linguaggio definito ad hoc per descrivere le reti stesse, comprensibile da NNSec. Ciò nonostante, il compito di creare e allenare le reti non riguarda NNSec e non sarà pertanto approfondita, discussa o analizzata alcuna tecnica in questo senso.\\
L'utilità del parser, oltre a quella di poter descrivere le reti neurali in una forma ad alto livello semplice e comprensibile, risiede anche nella capacità intrinseca (se adeguatamente inserito nel sistema) di poter caricare nuove reti neurali a caldo, il che permette di non dover fermare il server in alcun caso per effettuare operazioni del genere. Questo, seppure in molti casi sia dato per scontato, rappresenta comunque un'interessante e utile caratteristica.

\subsection{Grammatica dei file in ingresso}
Essendo NNSec un programma che mira ad utilizzare reti neurali ma trattandole indirettamente (ovvero, senza crearle o addestrarle, ma usando piuttosto il risultato finale di un processo già terminato a monte), la grammatica dei file di descrizione delle reti neurali avrebbe potuto basarsi su un formato di file già esistente. Ciò nonostante, è stata sviluppata una grammatica ad-hoc per NNSec a causa dei seguenti motivi:
\begin{itemize}
\item ogni programma candidato che proponga un proprio formato di file per la descrizione delle reti neurali non separa la descrizione della struttura relativa alla rete neurale da tutta una serie di parametri legati al programma stesso
\item sfruttare una grammatica creata per altri scopi costringe allo sviluppo di un parser più complesso capace di analizzare file contenenti dati che saranno scartati in buona percentuale e portando probabilmente a piegarsi a grammatiche scomode e poco flessibili
\item basarsi su un formato proprio di un altro software crea una dipendenza da tale strumento che potrebbe rappresentare una nota stonata col tempo e costringe l'utente a familiarizzare con tale programma, privandolo della libertà di scelta riguardo al come preparare le proprie reti neurali
\end{itemize}
Pertanto, NNSec è accompagnato da una grammatica (riportata in appendice) pensata appositamente per questo scopo, al tempo stesso semplice e intuitiva, così da permettere a chiunque di scrivere file di descrizione per reti neurali, ma anche completa e flessibile, in modo da lasciare spazio a virtuosismi e tecniche avanzate senza trascurare la possibilità di un ampliamento futuro che non dovesse per forza costringere alla riscrittura di tutti i file già esistenti per le reti neurali.\\
La possibilità di creare veri e propri traduttori da un formato come quello proposto da altri programmi al formato di ingresso per NNSec rimane sempre una strada percorribile e rende praticamente possibile l'uso di qualsiasi programma di creazione e allenamento per le reti neurali, a patto che poi si riesca a convertire i file da un formato all'altro (a mano o tramite strumenti automatici), cosa che per altro non richiede particolari abilità o conoscenza della materia. Questa è anche la strada seguita nella preparazione di reti neurali per effettuare alcuni test con NNSec, create e allenate con il tool JavaNNS (prelevabile da \cite{javanns}) e convertite nel formato comprensibile da NNSec tramite una serie di appositi script.

\subsection{JFlex e JavaCUP}
La creazione di una coppia di analizzatori lessicale e sintattico, utili per poter estrapolare potenziali elementi grammaticali da un flusso in ingresso e poterli valutare in quest'ottica decretandone l'appartenenza ad uno specifico linguaggio o meno, è un lavoro abbastanza arduo. Per quanto ci si possa sforzare, è piuttosto difficile ottenere un prodotto finale che sia efficiente anche se apparentemente perfettamente funzionante. Meglio affidarsi a strumenti automatici che, a partire da una collezione di simboli e la descrizione di una grammatica basata su di questi, producano un interprete tanto efficace quanto efficiente in pochi istanti, risparmiando non poca fatica agli sviluppatori.

In quest'ottica, anche nello sviluppo di NNSec è stato ceduto il passo all'uso di due software open-source molto utilizzati proprio per questo scopo: JFlex e JavaCUP. I due software citati sono reperibili dal web a partire da \cite{jflex} e \cite{javacup}.\\
Il primo dei due strumenti, JFlex, è utilizzato per la realizzazione di una classe in grado di spezzare un determinato flusso di ingresso in una serie di elementi predefiniti, specificati a priori, e di individuare i casi in cui vi siano oggetti non appartenenti a questo insieme. In questo modo, associando ad ogni elemento per esempio un identificativo numerico, si può pensare di dividere un ipotetico flusso continuo di caratteri in elementi atomici, rappresentandolo su di un flusso di valori interi più facilmente trattabile a valle del processo di suddivisione. Questa idea sfrutta il principio di \textit{divide et impera}, caro anche a molti altri algoritmi come quelli di ordinamento, per cui si separa il compito di interpretazione dei dati in ingresso da quello di valutazione riguardo alla correttezza sintattica di tali dati. L'oggetto prodotto da JFlex ha il compito di svolgere la prima delle due funzioni.\\
Per quanto riguarda JavaCUP, invece, esso ha il compito, basandosi sempre sullo stesso insieme di elementi predefiniti, di determinare come già anticipato la validità sintattica del flusso di elementi estratti dall'insieme di dati e l'appartenenza o meno di tale struttura di informazioni ad un linguaggio desiderato. Lavorando ad esempio su valori interi, ognuno corrispondente ad un determinato simbolo, il compito di questo oggetto è molto semplificato e lascia ampio spazio ad ottimizzazioni tramite l'uso di tabelle e speciali algoritmi concepiti proprio a questo scopo. La teoria che sta dietro al funzionamento di un parser e tutto ciò che è legato alle grammatiche e i linguaggi regolari esula dallo scopo di questa tesi e le classi realizzate, seppure funzionali allo scopo, sono molto semplici e in grado di interpretare un linguaggio a sua volta di facile comprensione e analisi.

\section{Cryptosystem}
Il subpackage \texttt{cryptosystem} contiene principalmente le classi fondamentali per quanto riguarda le sessioni di cifratura/decifratura, la quantizzazione e la mappatura dei valori reali, così da permettere al resto del sistema di usufruire di questi servizi in modo trasparente e senza sporcare il codice restante. In questo package sono presenti un insieme di classi che implementano il cifrario, analizzato in sezione \ref{subsec:cip}, e permettono di operare facilmente con valori reali, come discusso in sezione \ref{sec:wwni}.

Separare tanto le operazioni relative alla cifratura/decifratura dei messaggi quanto quelle relative alla gestione dei valori reali (quantizzati e rappresentati all'interno di un arco di valori interi positivi), permette di sviluppare nel resto del programma un codice più snello e pulito, che si appoggia a queste primitive senza implementare al suo interno alcuna operazione orientata in tal senso (se non le semplici chiamate di metodi e la creazione degli oggetti dovuti). Mettendo a disposizione uno strato come quello proposto, vengono messi sia i programmatori che gli studiosi interessati al codice in condizione di operare in un ambiente in cui cifrare o validare un valore consiste in una semplice invocazione di un metodo, come se queste operazioni fossero native e integrate nell'ambiente stesso.

\subsection{Numeri primi, chiavi pubbliche/private e BigInteger}\label{subsec:bigkey}
Prima di procedere con la descrizione del cifrario è utile ripassare alcuni concetti e inquadrare aspetti provenienti dalla teoria in uno scenario pratico. Per ulteriori approfondimenti si faccia riferimento a \cite{goldreich2001fcb} e \cite{goldreich2004fci}.

Una delle nuove frontiere della crittografia è rappresentata dalla crittografia asimmetrica, anche detta a chiave pubblica/privata. Supponendo che Bob e Alice vogliano scambiarsi dati in sicurezza, ad ognuno di loro è demandata la generazione di una coppia di chiavi pubblica e privata di cui:
\begin{itemize}
\item la chiave privata è segreta e viene utilizzata per decifrare i dati
\item la chiave pubblica viene distribuita alla controparte e utilizzata quindi per cifrare i dati
\end{itemize}
Supponendo che Alice voglia inviare un messaggio, dovrà cifrarlo con la chiave pubblica di Bob il quale potrà decifrarlo con la propria chiave privata. In alcun caso si potrà usare una stessa chiave per le due fasi, ovvero non si potrà decifrare con la stessa chiave con cui è avvenuta la cifratura.\\
Le chiavi pubbliche e private sono in molti casi generate a partire da una coppia di numeri primi $ p $ e $ q $ molto grandi, scelti a caso l'uno indipendentemente dall'altro e quindi elaborati in un qualche modo differente a seconda del cifrario. Ad esempio, a partire dai valori di cui sopra in RSA:
\begin{itemize}
\item si calcola il loro prodotto $ n $, chiamato modulo (dato che tutta l'aritmetica seguente è modulo $ n $)
\item si sceglie un numero $ e $, tale che sia coprimo con $ (p-1)(q-1) $; ovvero, si sceglie $ e $ tale che il massimo comune divisore fra $ e $ e $ (p-1)(q-1) $ sia $ 1 $.
\item si calcola un numero $ d $ tale che: $$ e\cdot d\; (mod\; (p-1)(q-1)) \equiv 1 $$
\end{itemize}
La chiave pubblica è rappresentata dalla coppia $ (n, e) $, mentre la chiave privata è data dalla coppia $ (n, d) $. La forza di RSA risiede nel fatto che fattorizzare il valore $ n $ nel tentativo di risalire ai due numeri primi che lo hanno generato è computazionalmente molto difficile soprattutto se $ n $ è molto grande.

I principali problemi di questi protocolli risiedono nella difficoltà di generazione di numeri pseudo-casuali e di numeri primi molto grandi.\\
Nel primo caso, esistono algoritmi in grado di generare una successione di numeri i cui elementi sono approssimativamente indipendenti l'uno dall'altro, anche se non tutti sono utilizzabili in crittografia. Un possibile esempio è dato dall'algoritmo BBS, o Blum Blum Shub (discusso in \cite{blumblumshub}).\\
Nel secondo caso, bisogna osservare che non esistono ad oggi algoritmi in grado di determinare con estrema certezza se un dato numero è primo o meno ed esistono alcuni numeri che presentano tutte le caratteristiche proprie dei numeri primi pur non essendo tali. Questo si ripercuote nella possibilità di incappare in numeri solo apparentemente primi e quindi si corre il rischio di essere in possesso di una coppia di chiavi fragile. Ciò nonostante, esistono metodi per effettuare un test di primalità per un numero come l'algoritmo di Miller-Rabin (di cui è data una trattazione completa in \cite{millerrabin}, dove sono analizzate anche le problematiche accennate poco sopra).

\paragraph{La soluzione BigInteger.}
Il linguaggio Java mette a disposizione la classe \texttt{BigInteger}\footnote{http://java.sun.com/j2se/1.5.0/docs/api/java/math/BigInteger.html} per risolvere in maniera comoda il problema e sollevare il programmatore dallo sviluppo di algoritmi mirati. Questa classe si basa proprio sul test di primalità di Miller-Rabin e permette di creare numeri primi per cui:
\begin{itemize}
\item è possibile definire una lunghezza in numero di bit, detta \textit{bitLength}, ottenendo così un numero primo compreso fra $ 0 $ e $ (2^{bitLength} - 1) $ inclusi
\item è possibile definire un livello di sicurezza detto \textit{certainty}, tale per cui la probabilità che il numero ottenuto rappresenti un numero primo sia superiore a $ \left( 1 - \frac{1}{2^{certainty}}\right) $
\end{itemize}
Inoltre, la classe \texttt{BigInteger} (largamente usata in NNSec) propone tutta una serie di metodi per poter eseguire operazioni fra oggetti di questo tipo. Ad esempio, sono presenti metodi per effettuare divisioni e moltiplicazioni, somme e sottrazioni ma anche per ricavare il minimo comune divisore fra due \texttt{BigInteger}, effettuare operazioni di modulo o test di primalità e tanto altro ancora.\\
Per approfondimenti sulla classe \texttt{BigInteger} si rimanda alla documentazione ufficiale del linguaggio Java.

\subsection{Il cifrario}
Analizzando la parte implementativa di NNSec e affrontando il concetto del cifrario preso in esame in sezione \ref{subsec:cip}, non sarà discusso come effettivamente funzionino o cosa si nasconda dietro alle primitive crittografiche (per una cui trattazione si rimanda a \cite{paillier} e \cite{brics}), ma piuttosto sarà aperta una parentesi su tutta una serie di tecniche messe a disposizione dal linguaggio Java e adottate nello sviluppo di questa classe.

Il cifrario infatti, rappresentato nella classe \texttt{Cryptosystem}, è uno degli elementi (anche se non l'unico) che basa la sua struttura sull'uso delle classi interne, o inner-class. Queste classi hanno alcune caratteristiche interessanti, brevemente riassunte in due punti: la loro capacità di referenziare la classe contenitrice accedendo ai suoi metodi e le sue variabili (nota importante, anche se private) con la sola limitazione che esse devono essere definite come statiche e così anche i metodi acceduti se anche la classe interna lo è; la possibilità di modificarne la visibilità (o \textit{scope}), così che possano risultare a solo uso e consumo della classe che le contiene oppure accedibili anche dagli altri elementi del sistema (addirittura, se pubbliche e statiche possono essere istanziate e utilizzate da tutti gli altri oggetti nel sistema semplicemente attraverso la dicitura classe\_contenitrice.classe\_contenuta).\\
Combinando quindi la possibilità di dichiarare una chiave privata come classe anch'essa privata interna al cifrario e la chiave pubblica come classe statica e a sua volta pubblica, con la capacità di presentare metodi statici accedibili da chiunque senza essere obbligati ad istanziare un cifrario a sé stante, ecco che la funzionalità completa è servita.\\
Infatti, ad Alice (che necessita di una coppia di chiavi pubblica e privata) basterà creare un nuovo cifrario che sarà utilizzabile senza difficoltà attraverso i metodi di interfaccia, sia per cifrare che per decifrare messaggi oltre che per esportare la chiave pubblica così da poterla dare ad altri soggetti (ovvero, a Bob). Per quanto riguarda Bob invece (che necessita solo di poter cifrare o decifrare messaggi, laddove possibile, tramite l'uso di una chiave pubblica fornita da Alice) anche in questo caso non esiste alcuna difficoltà: questo tipo di classe è accedibile per mezzo di metodi statici, senza essere obbligati a creare oggetti ex-novo sul proprio sistema se non ve ne fosse la necessità. Questo significa che Bob, possedendo la sola chiave pubblica di Alice, non avrà necessità di istanziare un nuovo cifrario per poterla utilizzare ma potrà usare tale chiave attraverso una serie di metodi statici della classe \texttt{Cryptosystem} che gli danno la possibilità di elaborare i dati.

Questa classe dimostra quindi come sia possibile realizzare e strutturare elementi particolarmente complessi ma utili a risolvere svariati problemi in modo elegante e pulito, semplicemente sfruttando tutte quelle caratteristiche che un linguaggio come Java mette a disposizione e sono spesso trascurate o, peggio ancora, del tutto ignorate dagli sviluppatori.

Una nota particolare va fatta in merito a questa classe, ma prima bisogna aprire e chiudere velocemente una piccola parentesi. Uno degli anti-pattern più famosi e discussi perché spesso seguito alla lettera (da notare che questi descrivono il modo sbagliato di fare le cose, quindi attenersi ad essi non è molto indicato) è detto \textit{Reinventare la ruota}. Molto brevemente, questo anti-pattern descrive il comportamento sbagliato di molti programmatori, i quali piuttosto che spendere poco del loro tempo a cercare qualcuno che abbia già affrontato (e risolto) il loro problema tendono ad impiegare molto del loro tempo riscrivendo da zero in modo fantasioso (e spesso di gran lunga meno efficiente) algoritmi, classi e funzioni di ogni tipo. In questo caso viene sfatato un po' questo mito e bisogna dire che la classe relativa al cifrario nasce come modifica (abbastanza ampia e profonda, a dire il vero) di un software giocattolo già pre-esistente fornito per testare l'algoritmo descritto e reperibile dalla rete Internet sulla pagina dello sviluppatore\footnote{http://www.daimi.au.dk/~jurik/research.html}.\\
È stata quindi seguita la via che prevede di adattare qualcosa di già esistente ai propri scopi, piuttosto che riprogettarlo da zero peccando di presunzione e rischiando di incappare in problemi di prestazioni.

\subsection{I numeri reali e la classe Mapper}
L'uso dei numeri reali come parametri di ingresso per reti neurali o come valori associati ai collegamenti fra i nodi che le compongono è abbastanza scontato in un ambiente reale, ma non lo è altrettanto quando si parla di dominio cifrato; infatti, in questo caso l'uso di numeri reali richiede tutta una serie di accorgimenti particolari che, altrimenti, ne impedirebbero la presenza. La problematica è nota ed è già stata evidenziata in sezione \ref{sec:wwni}, proponendo una possibile soluzione che viene di fatto implementata in questo package.

Per affrontare questo problema è nata la classe \texttt{Mapper}, una componente tanto semplice quanto importante all'interno del sistema, usata tanto dai client quanto dal server e che si occupa di quantizzare i valori reali per poi rappresentarli all'interno di un intervallo ben specificato di valori interi positivi, il tutto in base ad alcuni parametri forniti al momento della creazione. In particolare, questa classe deve essere a conoscenza del fattore di quantizzazione $ Q $ e della dimensione $ S $ dell'intervallo in cui i valori saranno rappresentati.\\
Questa classe propone un numero abbastanza vasto di metodi nella sua interfaccia, così da soddisfare ogni necessità; in particolare, sono presenti metodi per quantizzare e dequantizzare determinati valori o per rappresentarli all'interno dell'intervallo definito al momento della creazione, ma anche combinazioni di questi che permettono di ottenere in un'unica chiamata la rappresentazione quantizzata all'interno dell'intervallo specificato a partire da un numero reale in ingresso.\\
Quindi, la classe originariamente nata col solo scopo di convertire elementi fra due diversi domini è presto diventata un coltellino svizzero in cui riversare tutte le funzioni relative al trattamento dei valori che circolavano all'interno di NNSec, da usare ogni qualvolta vi fosse la necessità semplicemente tramite la chiamata di un metodo.

Volendo fare una breve considerazione, per come è stata progettata e pensata la classe descritta può addirittura andare oltre i confini di NNSec ed essere riutilizzata potenzialmente in molti software, grazie alle sue caratteristiche che esulano completamente dal sistema in cui si trova e che possono essere facilmente adattate in diversi casi, in modo facile e, se necessario, con banali modifiche al codice. Infatti, questa sembra essere la classe che, più di altre, rappresenta uno strumento tanto utile quanto generico, per caso e per necessità sfruttato in questa situazione ma per niente associabile in modo diretto ad NNSec. In fin dei conti, il riciclo del codice è uno dei principi base della programmazione orientata agli oggetti e lo sforzo nel cercare di programmare classi riutilizzabili è talvolta premiato, come in questo caso.

\section{Net}
Il subpackage \texttt{net} propone alcune classi di particolare interesse per la creazione, configurazione, estensione, occultamento e gestione delle reti neurali all'interno  di NNSec, in modo da permettere un semplice ed efficace controllo su questi oggetti. Queste classi operano nel rispetto dei principi riguardanti l'estensione del numero di neuroni e la permutazione delle loro posizioni all'interno dei singoli livelli, come descritto in sezione \ref{subsec:nnff}, e permettono di gestire allo stesso modo percettroni e reti neurali multi-livello feed-forward come già accennato in sezione \ref{sec:ps}.

In questo package sono contenute tutte le classi che hanno a che fare con le reti neurali, a partire dall'interfaccia a cui queste devono sottostare, passando per gli elementi componenti quali nodi e archi fra nodi per finire alla classe unica di gestione delle reti neurali, una sorta di controllore delle reti neurali che ha il compito di caricare quest'ultime nel sistema, configurarle, vigilare sugli accessi ad esse sia per l'uso che per il recupero di informazioni relative alla struttura e, secondo necessità, eliminarle dall'ambiente.

\subsection{Composizione + Permutazione = Confusione}\label{subsec:cpc}
Il principio alla base dell'occultamento in merito alla struttura interna delle reti neurali si basa su di una variante del noto pattern Composite, riportata in figura \ref{fig:comp}.

\begin{figure}
\centering
\includegraphics[scale=0.70]{img/composite.eps}
\caption{\figfont modello di composizione}\label{fig:comp}
\end{figure}

In questo modello, il client mantiene un riferimento all'interfaccia base per le reti neurali che, nella realtà, è implementata da due oggetti distinti: la classe rete neurale vera e propria ed una classe wrapper, o involucro, che viene istanziata passando come parametro un oggetto che implementi a sua volta l'interfaccia base e di cui ne occulta la struttura interna. Questa ultima operazione è ottenuta tramite una espansione del numero di nodi interni e una permutazione, nei limiti del possibile, delle posizioni degli elementi. Così facendo, si può consegnare al client un oggetto che rappresenta di fatto una rete neurale, come si aspetta, ma che potrebbe racchiudere la rete originale entro un numero potenzialmente senza limiti di incapsulamenti. Il client, di contro, non si accorgerà di stare operando con una rete incapsulata o meno e di quanto profondo sia il livello di incapsulamento, bensì esso maneggerà la rete in base al contratto specificato dall'interfaccia. Per una discussione più dettagliata di questo e molti altri pattern, è consigliata la lettura di \cite{designpattern}.\\
Da notare che, ovviamente, la metodologia di espansione adottata per occultare la struttura interna delle reti neurali non ne influenza affatto la conformazione, come descritto in sezione \ref{subsec:nnff}. Infatti, i nodi aggiuntivi non si collegano ai neuroni già presenti in alcun modo ma bensì concorrono a formare uno strato aggiuntivo interfogliandosi con essi per interallacciare i due livelli, così da espandere apparentemente la dimensione del singolo livello intermedio. Allo stesso modo, il processo di permutazione della posizione dei nodi non influenza l'ordinamento effettivo di visita dei nodi reali (importante in reti neurali feedforward, ad esempio), ma agisce solo su quei nodi che possono essere effettivamente scambiati di posizione; questo significa che, ad esempio, si potrà avere uno scambio di posizione fra nodi reali e nodi fittizi, così come anche fra neuroni reali appartenenti allo stesso livello che non presentano quindi collegamenti fra di loro ma solo verso altri nodi appartenenti ai livelli superiori e inferiori.

Il modello adottato permette di gestire le reti (nella figura della classe \texttt{NetManager}) e fornirle dietro richiesta occultandone il contenuto, proponendo ad ogni domanda per una stessa rete oggetti i cui componenti interni non variano ma la cui struttura è di volta in volta diversa. Infatti, sebbene i nodi di riempimento (anche detti nodi fittizi) vengano creati e inseriti all'atto dell'incapsulamento della rete neurale nel suo involucro e lasciati invariati nel tempo (così che un possibile attaccante non possa basarsi sull'analisi dei nodi che si ripresentano ad ogni richiesta o che invece variano nel tempo), la permutazione delle posizioni viene effettuata da parte del gestore a seguito di ogni richiesta per la specifica rete, ottenendo il risultato sopra descritto.

\subsection{Manager di reti}
Il gestore delle reti neurali, rappresentato dalla classe \texttt{NetManager}, è un complesso controllore per gli oggetti presenti nel sistema che ne regola l'accesso, il recupero delle informazioni associate alla singola rete neurale, l'impostazione dei parametri associati quali il fattore di quantizzazione o il fattore di espansione e permette il caricamento o l'eliminazione di nuovi elementi all'interno del sistema.

Il gestore delle reti neurali associa ad ogni singolo oggetto un valore intero per il recupero degli elementi su base 
identificatore. Esso presenta un tipo privato di oggetti interni non accessibili direttamente, più snelli e capaci di maneggiare la singola rete neurale, associati quindi singolarmente ad ogni nuovo elemento caricato nel sistema. Gli oggetti appartenenti a questa classe privata interna hanno alcune caratteristiche molto interessanti di seguito elencate:
\begin{itemize}
\item sono i reali responsabili del controllo sull'accesso alle reti neurali
\item contengono un semaforo binario per limitare le richieste soddisfatte a solo una per volta, accodando tutte le successive e servendole singolarmente in modo sequenziale
\item mantengono una rappresentazione della rete neurale affidata al loro controllo inserendola a priori in un involucro per occultarne il contenuto (si veda a tale proposito sezione \ref{subsec:cpc}), richiamando le funzioni di permutazione su di essa ogni volta che viene fornita verso l'esterno a seguito di una richiesta
\item ad essi è demandato il recupero delle informazioni sulla rete neurale in vari formati e livelli di completezza, così da implementare un efficace recupero di quest'ultime in base all'identità del richiedente (ad esempio, a seconda che la richiesta provenga dal server per la manutenzione o dal client per l'uso).
\end{itemize}
Basandosi sull'ipotesi di corretto funzionamento degli elementi interni a cui è affidata la gestione della singola rete neurale, il gestore di sistema implementa funzioni per il recupero delle informazioni relative a tutti gli oggetti contenuti (e non solamente al singolo), per l'associazione di una singola rete neurale al suo identificatore, per il caricamento, l'eliminazione e addirittura l'aggiornamento di queste, per l'impostazione dei parametri su base identificatore con filtraggio preventivo e per la richiesta in merito alla possibilità d'uso relativa alle reti neurali. Il compito del gestore delle reti neurali è sicuramente semplificato dall'uso degli elementi interni sopra descritti e questo comporta che esso sia limitato a funzioni di facciata molto semplici in termini di elaborazione.\\
La tecnica di delegazione delle mansioni fra i diversi elementi di un sistema è molto usata nella programmazione ad oggetti e permette, come in questo caso, di alleggerire e semplificare alcune classi a discapito dell'aggiunta di altri protagonisti che si fanno carico di far fronte a determinati compiti. In questo modo, pur aumentando il numero di classi presenti nel sistema (anche se spesso di poco, come in questo caso che prevede l'aggiunta di una sola classe ulteriore), risultano essere in generale più semplici e pertanto è più facile sia la comprensione da parte di terzi che la manutenzione o modifica.

\subsection{Modello unificato per reti neurali}
Il modello adottato per la rappresentazione delle reti neurali all'interno di NNSec merita una sezione a sé dedicata per vari motivi. Infatti, questo ha comportato addirittura delle modifiche agli algoritmi proposti nel protocollo originale che generalizzassero astraendo dal tipo di rete neurale maneggiata di volta in volta, proponendo un algoritmo unico adatto per ognuna di esse che non costringesse il flusso di esecuzione ad articolarsi su rami diversi a seconda dei dati.

\paragraph{Modelli diffusi.}
In letteratura, le reti neurali sono spesso rappresentate grazie all'uso di matrici e array. Infatti, supponendo di avere $ N $ nodi nella rete neurale logicamente numerati da $ 0 $ a $ N-1 $, il valore in essi contenuto può essere memorizzato tramite l'uso di un array di lunghezza $ N $ in cui ogni cella corrisponde al nodo avente indice pari a quello della cella stessa. Su questa base, si possono rappresentare i collegamenti fra i nodi (supponendo ad esempio che fra due nodi vi possa essere un solo collegamento) usando una matrice $ N\times N $, per cui il valore nella cella $ (i,j) $ rappresenta il peso del collegamento fra i nodi con indici rispettivamente pari a $ i $ e $ j $. La matrice è molto probabilmente sparsa e lo spreco di memoria consistente, ma l'accesso immediato ed efficiente. Una soluzione alternativa, meno performante ma più compatta in termini di memoria, è quella che prevede l'uso di liste collegate con indici, per cui ogni nodo mantiene memoria dei nodi ad esso collegati. In entrambi i casi, l'identità del nodo è debole e rappresentata dal solo valore ad esso associato, una soluzione che non si presta per operare in NNSec. Inoltre, in entrambi i casi bisogna utilizzare una serie di inter-allacciamenti ulteriori fra i nodi per mantenere memoria della loro appartenenza ad un livello piuttosto che ad un altro, o una qualsiasi tecnica che raggiunga lo stesso scopo se necessario.

\paragraph{Classi dedicate.}
Per dare ad ogni nodo e anche ad ogni collegamento fra nodi un'identità più forte sono state create due classi pubbliche interne all'interfaccia sviluppata per le reti neurali che proponessero appunto la possibilità di maneggiare più facilmente nodi e collegamenti fra questi. La classe nodo dà la possibilità ad esempio di associare al singolo elemento non solo un valore specifico, ma anche una propria funzione di attivazione e di uscita, una soglia, un gruppo (che rappresenta il livello di appartenenza) e ovviamente una serie di collegamenti da e verso altri nodi, cioè in entrata e in uscita dal nodo considerato. Allo stesso modo, la classe collegamento presenta la possibilità di mantenere un valore e di fornire velocemente informazioni sul nodo di provenienza e di destinazione del collegamento considerato. Discostandosi quindi da un modello più geometrico basato su vettori e matrici, è stato utilizzato un approccio decisamente più orientato agli oggetti dove la singola rete neurale è costruita componendo i singoli elementi di base.\\
La possibilità di impostare per un singolo neurone sia una funzione di attivazione che una funzione di uscita permette di comporre più funzioni in maniera facile e veloce, senza dover ricorrere a contorsionismi per elaborare un dato valore. Indicando la funzione di attivazione con $ f $ e la funzione di uscita con $ g $, si può immaginare la funzione di attivazione $ a $ associata al singolo nodo nella discussione teorica in sezione \ref{subsec:nn} come risultante dalla composizione delle precedenti, ovvero: $ a = g\circ f $.

\paragraph{Modello unificato.}
Utilizzando i mattoni descritti nel paragrafo precedente, è possibile adesso descrivere il modello unificato adottato in NNSec. Questo modello prevede la rappresentazione della rete neurale come array di nodi scandito in modo sequenziale. Ogni nodo è inserito all'interno del vettore nell'ordine di comparsa all'interno del sistema (cioè, in base alla posizione nel file di descrizione della rete neurale) e i collegamenti fra nodi sono memorizzati all'interno dei nodi stessi come collegamenti entranti o uscenti, quindi non vi è la necessità di mantenerne ulteriore memoria separata. La scansione sequenziale prevede che durante l'analisi dei nodi (ad esempio in una sessione di uso della rete neurale) questi siano prelevati dal vettore in ordine e quindi elaborati. Per recuperare il valore di un nodo collegato ad un altro, è sufficiente partire da quest'ultimo, recuperare il riferimento relativo al collegamento in ingresso e a quest'ultimo domandare quale sia il nodo da cui scaturisce. Questa rappresentazione si presta in modo particolare per modelli feed-forward (fra cui è incluso anche il percettrone, inteso come degenerazione di tali modelli), infatti basta elencare i nodi nel file di descrizione della rete neurale nell'ordine in cui questi devono essere visitati e al resto penserà NNSec. Questo modello, pertanto, permette di astrarre dalla reale natura della rete neurale in uso e descrivere ognuna di queste con un modello unico adattabile a tutte le situazioni, la cui unica limitazione è il fatto che i nodi vengono visitati in ordine sequenziale (ma, del resto, il protocollo era concepito per percettroni e reti feed-forward, pertanto tutti i casi sono comunque accolti fra le braccia del nuovo modello).\\
L'unica questione che rimane in sospeso è come vengano espansi i livelli intermedi e come vengano permutati i nodi interni ad ogni livello, dato che il modello apparentemente non mantiene traccia dell'appartenenza di un singolo nodo ad uno specifico livello. La soluzione sarà discussa nel paragrafo seguente ma si osservi in questa sede il fatto che questo modello permette di astrarre dalla struttura multi-livello delle reti neurali e quindi mette a disposizione la possibilità di descrivere potenzialmente reti neurali di qualsiasi tipo.

\paragraph{Occultamento.}
Il modello descritto introduce per ogni nodo un gruppo di appartenenza che può anche non essere impostato (ovvero avere valore nullo, o zero). Questo parametro può ovviamente essere utilizzato per legare fra loro un insieme di nodi che sarà, quindi, potenzialmente permutato in maniera del tutto casuale, come descritto in sezione \ref{subsec:nnff}. Infatti, il gruppo di appartenenza può essere visto come il livello a cui ogni nodo è associato e assegnare quindi a due nodi uno stesso gruppo significa collocarli in uno stesso livello delal rete neurale. Inoltre, nella fase di inserimento dei nodi fittizi all'interno della rete neurale occultata questi vengono associati di volta in volta ad un gruppo specifico di livello intermedio il che comporta, come conseguenza, l'espansione in maniera del tutto casuale dei livelli intermedi. Questa, per altro, può essere controllata in modo molto fine attraverso un oculato assegnamento delle classi ai singoli nodi. In questo modo ci si ricollega alle osservazioni fatte in sezione \ref{subsec:nnff}, ovvero:
\begin{itemize}
\item il numero di livelli $ L $ può essere controllato nella fase di configurazione della rete neurale, in modo che questa operazione non influisca sul risultato finale ma renda l'illusione di una rete neurale contenente di fatto un livello intermedio aggiuntivo; infatti, se si desidera aggiungere un livello nascosto ulteriore basta dividere in due gruppi i neuroni appartenenti ad uno stesso livello e assegnare ai due gruppi classi di appartenenza diverse, con la sola limitazione che si può avere un numero massimo di livelli $ L_{max} $ pari al numero $ N $ di neuroni presenti all'interno della rete neurale, 
\item le dimensioni $ M_i $ in termini di numero di neuroni dei singoli livelli sono gestite a run-time da NNSec stesso, il quale introducendo neuroni fittizi nella rete neurale e distribuendoli in modo casuale fra i diversi livelli permette di avere valori $ M_i $ ogni volta diversi e assolutamente indipendenti da parametri relativi alla rete neurale in esame (come il numero di neuroni originali o il numero di livelli)
\end{itemize}
Con questa tecnica, i compiti di occultamento della rete e permutazione dei nodi sono lasciati in parte all'utente lato server (che ha la libertà di decisione sul numero di livelli, ovvero sulla lunghezza massima del cammino fra neuroni di ingresso e di uscita) e in parte al programma che si occupa di riempire in modo automatico i diversi livelli con nodi fittizi permutandone poi l'ordine e confondendoli con i neuroni originali. Tutto ciò può sembrare forse complicato a prima vista, ma consegna all'utente un modo raffinato, potente e flessibile per gestire la distribuzione dei nodi sui diversi livelli intermedi e conseguentemente il loro occultamento.\\
L'ipotesi su cui si basa questa idea è che i nodi appartenenti ad uno stesso livello non presentano collegamenti fra di loro, altrimenti l'ordine di visita assumerebbe importanza e non potrebbero essere permutati senza incappare in errori sul risultato. Inoltre, sarebbe consigliabile assegnare ad uno stesso livello solamente neuroni che presentano collegamenti in ingresso provenienti da nodi senza classe o con indice di classe inferiore e collegamenti in uscita verso nodi senza classe o con indice di classe superiore, proprio come in realtà vengono assegnati i neuroni ad un livello piuttosto che un altro in una rete feed-forward aciclica.

\paragraph{Ripercussioni sul protocollo.}
Tutto quanto sopra descritto si ripercuote infine sul protocollo originale. Infatti, come detto, viene usato in NNSec un modello di rete neurale che astrae dalla natura di percettrone o rete neurale con uno, dieci, cento livelli, ma bensì propone una generalizzazione unica per tutti questi tipi. Di conseguenza, è sorta la necessità di trovare un algoritmo che a sua volta generalizzasse rispetto al tipo di rete e fosse applicabile al nuovo modello, senza dover ricorrere a due algoritmi diversi oppure un algoritmo unico che presentasse due rami di esecuzione diversi discriminando sulla tipologia di rete neurale a monte. Fortunatamente, i due algoritmi descritti dal protocollo originale per l'applicazione a percettroni e reti neurali multi-livello feed-forward (discussi in sezione \ref{sec:proto}) hanno molti punti in comune e differiscono solo nella fase di trattamento dei livelli intermedi, assente per il percettrone e piuttosto articolata per le altre reti neurali. Quindi, è bastato sviluppare un algoritmo che fosse una fusione dei due e che generalizzasse dal tipo di rete senza diramare il flusso di esecuzione a seconda dei dati proposti, ma bensì trattando il modello unico in un modo che fosse corretto per qualsiasi rete neurale in esso rappresentata. L'algoritmo risultante altro non è che l'algoritmo proposto per trattare reti neurali con un numero variabile di livelli intermedi, adeguatamente modificato per trattare il modello unico generico (ovvero anche i casi in cui il numero di livelli intermedi sia pari a zero). Questo, infatti, si adatta perfettamente anche al caso in cui tale modello descriva un percettrone, in quanto si basa alla fine sui nodi della rete neurale (e non sulla sua struttura) e su di questi basa tutto il suo lavoro.

\paragraph{Pro e contro.}
Ovviamente, tutto questo ha sia dei pro che dei contro.\\
Prima di tutto, va detto che il modello permette di astrarre dal tipo di rete e di conseguenza conduce ad un numero minore di algoritmi coinvolti adatti a tutti gli usi e di gran lunga più semplici ed efficienti; infatti, dividere l'esecuzione su due algoritmi ed introdurre una guardia che discriminasse in base al tipo di rete avrebbe appesantito il tutto rendendo la gestione assai più complessa.\\
Di contro, però, il modello unico è meno stringente e permette anche di descrivere reti neurali assolutamente senza senso e il cui risultato è del tutto imprevedibile, proprio perché esso dà la possibilità di disegnare qualsiasi tipo di rete neurale; del resto, però, questo è anche il modo sbagliato di usare il software e davanti a queste situazioni si può fare poco perché ogni programma, se usato malamente, darà risultati inattesi. Quindi, si può dire che questo rovescio della medaglia non è così preoccupante, perché rappresenta solo il caso in cui il software funziona male se usato male e questa è, del resto, la norma in molti casi.\\
Un cenno infine sulle responsabilità degli utenti. Per quanto riguarda gli utenti lato client, l'uso di NNSec non comporta difficoltà e non richiede particolari conoscenze, sollevando da molte responsabilità e occupandosi di tutti gli aspetti necessari all'espletamento del servizio. Di contro, lato server l'utente ha più libertà ma anche più responsabilità: infatti, se da una parte il processo di occultamento della rete neurale può essere controllato in modo molto fine, dall'altro un errore in questo frangente potrebbe rendere del tutto vano lo sforzo. Anche in questo caso, non esistono compromessi e la libertà di decisione ha inevitabilmente un costo in termini di responsabilità. In NNSec è stata scelta la via della flessibilità, cercando di ottenere un potente mezzo con cui modellare le cose a proprio piacimento, a discapito della responsabilità crescente in seno all'utente.

Da notare, infine, che il numero di livelli deciso in maniera implicita all'atto della stesura del file di descrizione della rete neurale rappresenta il valore $ L $ introdotto in sezione \ref{subsec:nnff}, mentre la successione data dai numeri di nodi associati ad ogni singolo livello è equivalente alla successione indicata con $ M_i $ sempre in sezione \ref{subsec:nnff}. Guardando questi parametri sotto questa luce si vede come l'implementazione finale non si discosti dal modello proposto in teoria e pertanto sono valide tutte le osservazioni fatte precedentemente basate appunto sui valori $ L $ e $ M_i $.

\section{Server}
Il subpackage \texttt{server} propone tutte le componenti utili alla fornitura dei servizi e alla configurazione dell'ambiente per una corretta interazione con i client, mettendo a disposizione anche una comoda GUI per permettere all'utente finale di interagire col sistema influenzandone il comportamento.

Sicuramente, tralasciando la GUI che altro non è se non un mezzo per semplificare la vita al gestore del sistema (descritta nelle sue componenti in appendice), il server propone alcune classi e spunti interessanti che lo rendono appetibile dal punto di vista del programmatore.\\ Infatti, senza scendere troppo in dettagli tecnici, esso basa il suo funzionamento sul noto pattern creazionale Factory e permette di servire più richieste contemporaneamente, aggirando di fatto la tecnologia a cui si appoggia. Inoltre, questo pacchetto racchiude la componente lato server a cui è richiesta la messa in pratica del protocollo e che rappresenta, quindi, una delle classi principali dell'intero progetto.\\
L'importanza di una interfaccia attraverso cui amministrare in maniera semplice e veloce l'intero sistema non è poi da trascurare e rappresenta una comodità per chi si trova a dover fare fronte al problema, alleggerendo il lavoro e semplificando di non poco le gestione del server.

\subsection{Factory Remota}\label{subsec:remfac}
Una delle evoluzioni principali, nonché uno degli aspetti più interessanti, del modello client/server è sicuramente la possibilità di servire più client contemporaneamente senza dover accodare le richieste servendole singolarmente (una modalità che si potrebbe definire rudimentale per l'offerta di servizi). Questa rappresenta sicuramente una caratteristica interessante anche e soprattutto in NNSec, dove il sistema lato server presenta e gestisce più reti neurali accedibili separatemente e indipendentemente l'una dall'altra.

Infatti, servendo un solo client per volta e rifiutando o (nel migliore dei casi) accodando le richieste successive, laddove due differenti domande siano per due differenti reti neurali si pecca sicuramente di inefficienza (per non parlare dell'efficacia della soluzione, la quale deficienza si ripercuote in termini di nervosismo per gli utenti che devono aspettare in coda quando la loro rete neurale è disponibile). Anche su macchine mono-processore, dove comunque le richieste verrebbero servite singolarmente, l'idea (che poi altro non è che la base dei sistemi multi-threading) di gestire più richieste contemporaneamente interallacciando la loro esecuzione permette di dare all'utente una risposta immediata in termini di accoglimento della domanda e l'impressione di avere un server a sé dedicato per la fornitura dei servizi. Anche perché, bisogna osservare che effettivamente nelle fasi di trasmissione dei dati ed elaborazione lato client, il server risulta effettivamente disponibile per poter effettuare altre operazioni o dedicarsi ad altre richieste.\\
Si intuisce facilmente che una situazione in cui le richieste sono servite sequenzialmente (ad esempio, basandosi sull'ordine di arrivo) può anche portare ad un drastico allungamento dei tempi di attesa e questo è proprio il caso di NNSec. Infatti, se una rete neurale è composta da un numero particolarmente grande di nodi e collegamenti fra nodi, aumenta di conseguenza il traffico fra client e server per l'espletamento di una richiesta, il tutto appesantito dalla componente crittografica che rappresenta di fatto la parte più impegnativa in termini di tempo di calcolo. Ciò nonostante, il server non può in alcun momento interrompersi per dedicarsi ad un'altra richiesta e questo va a discapito dei tempi di risposta.\\
In quest'ottica, NNSec è stato progettato per poter rispondere a più client contemporaneamente, aggirando alcune limitazioni imposte dal linguaggio e la tecnologia scelta, come spiegato in sezione \ref{sec:commodel}.

\begin{figure}
\centering
\includegraphics[scale=0.70]{img/factory.eps}
\caption{\figfont factory in NNSec}\label{fig:fact}
\end{figure}

In questo caso risulta utile l'applicazione di un pattern molto noto che assume il nome di Factory pattern ed è mostrato in figura \ref{fig:fact}, così come viene implementato ed utilizzato all'interno di NNSec. L'utilizzo di questo modello prevede una variazione alla struttura precedente, per cui il server altro non è che un oggetto in grado di istanziare a sua volta altre classi (potenzialmente, senza limiti, se non quelli imposti dalla macchina su cui esegue) a cui i client potranno fare riferimento per le loro richieste.\\
Questa organizzazione presenta alcuni risvolti positivi, di seguito elencati:
\begin{itemize}
\item il tempo di creazione di un riferimento da parte del server può essere considerato trascurabile, quindi ogni client avrà la possibilità di interagire immediatamente col proprio oggetto associato vedendo accolte le proprie richieste entro breve termine
\item il singolo client che desidera avere solo informazioni sulla lista delle reti neurali disponibili non dovrà aspettare che la lunga e pesante elaborazione di altri client giunti prima di lui termini per poter avere ciò che desidera, ma sarà servito immediatamente
\item se il server presenta più reti neurali e si hanno richieste per reti neurali diverse da parte di diversi client, queste saranno servite contemporaneamente senza dover attendere (permutandone ogni volta le posizioni dei nodi come descritto nelle sezioni \ref{subsec:nnff} e \ref{subsec:cpc}); ovviamente se la richiesta è per una stessa rete neurale il modello adottato non risolve il problema ma in linea di massima permette di abbattere i tempi di attesa dei singoli client in molti casi
\end{itemize}
Sull'ultimo punto, è importante approfondire ulteriormente. Infatti, il problema dell'accodamento di richieste per una stessa rete neurale può effettivamente essere del tutto risolto con una tecnica che permetta di clonare l'oggetto in questione ad ogni richiesta di utilizzo. In questo modo, due client che richiedono una stessa rete neurale otterranno due copie identiche ma distinte di questa e potranno operare contemporaneamente. Ciò nonostante, esiste un rovescio della medaglia: la soluzione introduce un carico aggiuntivo a seguito di ogni richiesta che ritarda la fornitura del servizio a causa della necessità di duplicazione delle reti neurali. Quest'ultimo aspetto potrebbe incidere sulle prestazioni nei casi in cui le reti siano di dimensioni molto elevate e si avrebbe un inevitabile peggioramento in tutti i casi in cui non vi siano richieste multiple. Infatti, nell'ipotesi che esista un solo client che richiede una determinata rete questo dovrà comunque sopportare il carico aggiuntivo dovuto alla duplicazione.\\
Non esiste un modo per determinare in maniera chiara e definitiva quale delle due soluzioni sia migliore o se esista una soluzione intermedia ottima, infatti:
\begin{itemize}
\item nel caso dell'accodamento si hanno migliori prestazioni su reti neurali accedute sporadicamente o che comunque ricevono poche richieste contemporanee, ma il comportamento degenera laddove si abbiano due o più richieste simultanee per una stessa rete neurale
\item nel caso della duplicazione sulle reti neurali si hanno migliori prestazioni in caso di più richieste contemporanee per una stessa rete neurale ma con un prezzo aggiuntivo dovuto alla copia della rete che può portare a peggioramenti significativi in caso di richieste singole
\item nel caso di soluzioni intermedie come quella che presuppone di dare la rete neurale al primo richiedente e produrre copie diverse per richieste successive, la quale sembrerebbe effettivamente un buon compromesso, sono introdotte tutta una serie di problematiche legate alla sicurezza dei dati in quanto le copie sarebbero fatte a partire da una rete neurale in uso e quindi contenente valori sensibili presenti all'interno dei singoli nodi
\end{itemize}

\subsection{I lavoratori}
Il lavoro, lato server, non è svolto dall'oggetto in ascolto per le richieste entranti, come accennato, ma bensì da un insieme di oggetti istanziati da quest'ultimo e associati al singolo client. Questi oggetti sono i lavoratori, rappresentati dalla classe \texttt{Worker}.

Questi elementi offrono tutta una serie di servizi nella loro interfaccia verso i client e si pongono come membrana fra di essi e il gestore delle reti, filtrando e regolando le richieste. Inoltre, presentano un ambiente interno impostabile dai diversi client, utile per la sessione di utilizzo delle reti neurali, che prevede la presenza di una chiave pubblica fornita dal client associato e alcuni valori concordati con quest'ultimo relativi all'utilizzo della rete neurale richiesta, variabili da interazione ad interazione (la chiave, invece, potrebbe restare anche la stessa, se i client decidono di non generarne di nuove a seguito di richieste successive).\\
Le istanze della classe \texttt{Worker}, ovvero i lavoratori, sono gli oggetti all'interno dell'intero progetto a cui è demandato il lavoro più impegnativo. Essi infatti possono espletare le richieste dei client nel caso questi richiedano informazioni sulle reti neurali disponibili, ma anche interagire con loro e calcolare l'output di una determinata rete neurale laddove pervenga una richiesta in tal senso. Se è vero che sarà preoccupazione dei client configurare ad-hoc l'ambiente dei lavoratori fornendo la propria chiave pubblica e concordando i parametri da usare durante l'elaborazione (e per questo, l'interfaccia di questi ultimi mette a disposizione tutti i metodi necessari), non si può dire altrettanto per quanto riguarda l'uso delle reti e il recupero dei valori di uscita: questa operazione, infatti, è affidata ai lavoratori che, pazientemente, dovranno computare i valori dei singoli nodi, passo dopo passo, interagendo (come già illustrato nell'analisi del protocollo) con i client al fine di ottenere il risultato atteso.\\
Questa fase rappresenta gran parte del carico computazionale dell'intero processo che, per come è strutturato il protocollo, è particolarmente sbilanciato e prevede lato server l'impegno più grosso per svolgere la componente più consistente dell'elaborazione.

\section{Client}
Il subpackage \texttt{client} introduce nel progetto le classi importanti per l'implementazione del protocollo dal punto di vista dell'utilizzatore finale, ovvero di chi vorrà servirsi delle reti neurali messe a disposizione come servizio remoto.

Questo pacchetto prevede prima di tutto una GUI minimale (descritta nelle sue componenti in appendice), ovvero una interfaccia grafica molto semplice tramite cui l'utilizzatore potrà decidere di creare o distruggere una connessione e reimpostare creandola ex-novo la propria chiave pubblica (e, di conseguenza, anche la chiave privata), decidendo tanto la lunghezza in numero di bit della chiave quanto un parametro di probabilità relativo al fatto che la funzione di creazione operi correttamente. Gli aspetti riguardanti questi argomenti sono già stati discussi e approfonditi in sezione \ref{subsec:bigkey}.\\
Il pacchetto client però non fornisce solamente le classi della GUI, bensì racchiude una serie di classi di gran lunga più importanti di questa, quali il modulo di comunicazione e il calcolatore, due elementi direttamente coinvolti nel protocollo proposto e aventi un ruolo abbastanza centrale.

\subsection{Modulo di comunicazione}
Il modulo di comunicazione rappresenta un'interfaccia fra il client e il server, o meglio fra il client e il lavoratore associato ad esso e residente sul server, un livello intermedio attraverso cui passano tutte le comunicazioni dell'utente finale e che si fa carico di effettuare le giuste chiamate di metodo per ottenere ciò che è richiesto.

Questo componente si preoccupa di stabilire una connessione in modo corretto con il server, passando per il registro apposito indicato dall'utente, richiedendo un lavoratore con cui poter interagire per le richieste future e di cui manterrà un riferimento nel tempo. Inoltre, ha la capacità anche di troncare la connessione stessa dietro richiesta, il che molto semplicemente consiste nel cancellare il riferimento remoto al proprio lavoratore.\\
La funzione più importante del modulo di comunicazione, però, è quella che lo vede interagire col proprio lavoratore associato per l'utilizzo di una rete neurale remota. Sebbene questa operazione possa sembrare abbastanza facile e nonostante il grosso del carico computazionale sia sulle spalle del server e non del client, questo componente svolge due ruoli importanti: da un lato si occupa della configurazione dell'ambiente del proprio lavoratore così che il risultato possa essere computato senza errori, mentre dall'altro istanzia ed esporta il calcolatore, un elemento a cui il lavoratore sul lato server si appoggerà per svolgere delle funzioni che, altrimenti, sarebbe impossibilitato dal portare a termine.\\
Nell'impostare l'ambiente ed espletare le funzioni relative al protocollo discusso in sezione \ref{sec:proto}, il modulo di comunicazione svolge diversi compiti:
\begin{itemize}
\item si occupa di stabilire un valore relativo alle sessioni di cifratura e decifratura, ricavabile da alcuni parametri relativi alla rete che desidera usare e forniti dal lavoratore
\item concorda, o meglio convalida se possibile, il fattore di quantizzazione della rete neurale, utile per poter fornire valori in ingresso reali anziché solo valori interi
\item istanzia un oggetto della classe \texttt{Calculator} in grado di applicare diverse funzioni ai valori in ingresso e lo fornisce al lavoratore, il quale lo userà per calcolare valori altrimenti non calcolabili
\item si fa carico della cifratura dei valori in ingresso, una volta stabiliti gli estremi per poter procedere, e la conseguente decifratura dei risultati ottenuti
\end{itemize}

\subsection{Il calcolatore}
Il calcolatore è nato come rimedio ad un problema che si è presentato durante le fasi di sviluppo e ha assunto immediatamente un ruolo importante all'interno del protocollo proposto: senza di lui, infatti, il server non sarebbe in grado di calcolare i risultati restituiti da alcuna rete neurale.

Questo componente è nato, come sarà spiegato in sezione \ref{subsec:fourfour}, dal problema del riferimento circolare. Di fatto, esso incapsula una serie di funzioni recuperabili tramite identificatore e necessariamente dislocate lato client in quanto non applicabili ai valori cifrati. Infatti, se grazie alle caratteristiche omomorfiche del cifrario molte funzioni lineari come la somma e la moltiplicazione possono essere effettuate in dominio cifrato ripercuotendosi sotto altra forma in dominio non cifrato, secondo necessità, alcune altre come la sigmoide o la funzione segno o, più in generale, le operazioni non lineari non possono essere messe in pratica in alcun modo.\\
Questo limita la capacità del server di operare in modo solitario e restituire quanto calcolato, ma lo costringe bensì ad interagire obbligatoriamente con il client che ha fatto richiesta per il risultato, nelle vesti appunto del calcolatore. Inoltre la fase di collaborazione, per come è stato progettato il protocollo, prevede due modalità di interazione che purifichino i valori dalle impurità assorbite durante la loro computazione lato server.\\
Il perché dell'esistenza di due modalità è presto spiegato. Come già illustrato parlando del protocollo, il risultato della computazione del valore di un determinato nodo passa tramite una specifica procedura che porta ad una doppia quantizzazione indesiderata ma inevitabile. Questo inconveniente viene quindi corretto al momento del calcolo del valore di attivazione del nodo, lato client, da parte del calcolatore, in quanto il valore viene decifrato ed è quindi facilmente gestibile anche in tal senso senza grossi sforzi. Risulta necessaria però un'altra modalità di funzionamento. Infatti, nel caso in cui un nodo presenti anche una funzione di uscita oltre alla funzione di attivazione (la prima è richiamata subito dopo l'altra, senza altre operazioni intermedie), questa riceve un valore che è già stato ripulito delle impurità e non deve quindi in alcun modo essere dequantizzato un numero eccessivo di volte come nel caso precedente, pena il ritorno di risultati falsati.\\
Il calcolatore mette quindi a disposizione tutto il necessario per calcolare funzioni di attivazione e/o uscita e lascia al chiamante, ovviamente, la scelta della modalità in cui si vuole eseguire.

\section{Modello di comunicazione}\label{sec:commodel}
NNSec prevede di sfruttare alcune delle caratteristiche più interessanti messe a disposizione dal linguaggio Java, tanto in termini di tecnologie (come RMI, o Remote Method Invocation) quanto in termini di librerie crittografiche (come il supporto a SSL, o Secure Socket Layer, descritto in \cite{ssl}). Ma non si limita qua. Appoggiandosi a queste primitive e combinandole con il modello di comunicazione presente in NNSec, in cui è adottata una struttura che vede coinvolti quattro elementi principali, si concorre ad ottenere caratteristiche di flessibilità, accessi multipli concorrenti, sicurezza, efficacia ed efficenza.\\
Come questo sia possibile è spiegato nei punti che seguono:
\begin{itemize}
\item flessibilità: l'uso della tecnologia RMI permette di sviluppare l'intero software come un'entità unica e omogenea tralasciando quasi totalmente i dettagli relativi alla comunicazione via rete, racchiusi in una membrana fra client e server apparentemente invisibile che pensa a tutti i problemi relativi alla trasmissione/ricezione, gestione dei riferimenti remoti, invio dei dati e quant'altro
\item accessi multipli concorrenti: tramite metodologie di programmazione avanzate, integrate con quelle messe a disposizione dal linguaggio, si lascia spazio ad un modello ad accesso multiplo in cui un solo server è in grado di servire un numero potenzialmente senza limiti di client, gestendo il corretto accesso alle risorse del sistema ed evitando problemi quali la non integrità sui dati
\item sicurezza: sfruttando, oltre al cifrario interno utile all'implementazione del protocollo proposto, canali cifrati stabiliti fra client e server, vengono innalzati i livelli di sicurezza e viene resa la vita un po' più dura ai possibili attaccanti; ovviamente, la sicurezza dell'intero sistema risiede sulla sicurezza delle componenti sottostanti e laddove questa verrà meno comporterà anche serie ripercussioni sull'intero progetto
\item efficacia ed efficenza: la risoluzione elegante di alcune problematiche di programmazione altrimenti piuttosto fastidiose ha permesso di sviluppare un software tanto efficace quanto efficiente, che raggiunga il risultato corretto senza disperdere le proprie energie; l'apparente complessità si dissolve in soluzioni che prevedono una interazione chiara e pulita fra le parti, senza inutili complicazioni
\end{itemize}
Di seguito saranno analizzate più approfonditamente alcune aree tematiche interessanti relative ai punti di cui sopra, proponendo laddove siano introdotti problemi reali anche soluzioni reali.

\paragraph{Remote Method Invocation.}
NNSec può essere immaginato come un software monolitico eseguibile su di una macchina che permetta la multi-utenza, concepito per gestire richieste concorrenti da parte di più individui. Questa visione delle cose costringe comunque il progetto ad una frammentazione interna fra un componente centrale che rappresenta il cuore del programma, o core, e l'interfaccia utente intesa in termini di richieste verso il core. Partendo da questo punto di vista, lo sviluppo è progredito lungo questa strada ed è stata mantenuta questa visione del programma come entità omogenea ma internamente separata in due parti.\\
A questo punto, entra in gioco la tecnologia RMI (ampiamente discussa e trattata in \cite{javarmi} tramite specifiche, guide ed esempi), o Remote Method Invocation, una evoluzione logica delle più datate RPC (Remote Procedure Call), nata con l'avvento dei linguaggi ad oggetti e ad essi associata. Infatti, una volta concepito il software come sopra esposto, tramite l'uso di questa tecnologia frapposta nelle comunicazioni fra core e interfaccia utente si possono dislocare i diversi oggetti componenti il programma su una rete (ma anche sulla stessa macchina, mantenendo la struttura originale) permettendo comunque loro di comunicare come se residenti tutti su una stessa unità fisica. Questo concetto cerca di avvicinare il modello client-server puro, non decisamente proprio di NNSec, verso un modello ibrido che mantiene ancora una parentela col precedente ma che lascia immaginare il prodotto finale come un'entità unica e indissolubile (le cui parti sono assolutamente inutili l'una senza l'altra).

\paragraph{Secure Socket Layer.}
Per quanto riguarda la sicurezza, una regola sempre valida è che questa non è mai abbastanza. Inoltre, le specifiche del protocollo descritto nel capitolo \ref{cap:one} impongono che la comunicazione fra client e server avvenga su un canale cifrato. NNSec crea quindi fra le parti coinvolte (client e server) un canale a sua volta cifrato basandosi sull'ormai affermato protocollo SSL nato appunto con lo scopo di fornire comunicazioni sicure sulla rete e descritto in \cite{ssl}.\\
Questa scelta, seppure innegabilmente importante, introduce non poca complessità nel progetto e qualche pensiero di troppo per l'utilizzatore finale. Infatti, tanto chi gestirà il server quanto chi vorrà usufruire dei servizi tramite il client, sarà costretto a produrre o convalidare un certificato allo scopo di poter stabilire correttamente la comunicazione. Va detto che, del resto, Java offre tutti gli strumenti (compresi alcuni utili programmi) per ottenere in modo semplice e veloce quanto serve, quindi il tutto non rappresenta niente di particolarmente preoccupante.

\subsection{I quattro moschettieri}\label{subsec:fourfour}
La parte più rilevante dell'intero progetto non è ovviamente la GUI che permette all'utente finale di interagire con client e/o server, né tantomeno il parser che permette di caricare in modo automatico e veloce una nuova rete a caldo, tutti elementi importanti del programma ma non direttamente coinvolti nell'implementazione del protocollo. Ciò che attira l'attenzione e che effettivamente rappresenta il cuore di NNSec è il modello di comunicazione vero e proprio fra client e server, messo in pratica da sole quattro classi (di cui, per altro, una ha solo un ruolo marginale). Queste classi implementano di fatto il protocollo descritto in capitolo \ref{cap:one}.\\
La tecnica di comunicazione adottata permette di risolvere in modo pulito alcuni problemi di progetto abbastanza rilevanti e aggirare con eleganza tutta una serie di limitazioni di cui soffre il normale modello di comunicazione client-server spesso proposto in applicazioni basate su RMI. Di seguito, sono discussi alcuni aspetti importanti del modello di comunicazione e verrà proposta di volta in volta una veloce scappatoia (spesso disarmante  nella sua semplicità) per sfuggire da apparenti vicoli cechi, terminando con l'illustrazione del modello di comunicazione nella sua totalità.

\paragraph{Riferimento circolare.}
Il modello di comunicazione che nasce spontaneo da una prima analisi del protocollo è abbastanza semplice. Basti pensare che se è vero che la parte client chiama la corrispettiva componente server per usufruire dei suoi servizi, quest'ultima a sua volta ha bisogno di potersi appoggiare al chiamante per i motivi illustrati in sezione \ref{subsec:req} (e che, per brevità, non saranno discussi nuovamente in questa sede). Questo modello però introduce in modo abbastanza subdolo una dipendenza circolare fra le due parti coinvolte per cui l'una non ha senso di essere senza l'altra durante una sessione collaborativa.\\
Ciò potrebbe anche essere trascurato (sebbene una dipendenza circolare del genere sia come una bomba ad orologeria pronta ad esplodere) se non fosse che l'uso di RMI rende impossibile la compilazione di due classi così fatte. Infatti, per poter usufruire dei vantaggi offerti da RMI, posto che un oggetto di una classe \texttt{A} voglia sfruttare i servizi di un oggetto di una classe remota \texttt{B}, il primo dovrà poter contare su una interfaccia di riferimento detta \texttt{B\_Stub} che presenta gli stessi metodi remoti offerti da \texttt{B} e si occupa della comunicazione sulla rete (oltre a tutta una serie di cose meno importanti da questo punto di vista). Va detto che l'interfaccia \texttt{B\_Stub} è creata a partire dalla classe già compilata \texttt{B}.\\
Nel caso specifico di NNSec, però, la faccenda si fa più complessa: infatti, se \texttt{A} ha bisogno di \texttt{B\_Stub}, così anche \texttt{B} ha bisogno di \texttt{A\_Stub} e sia \texttt{A} che \texttt{B} nel loro codice fanno riferimento alle rispettive altrui interfacce. Pertanto, la classe \texttt{A} non può essere compilata in quanto non riesce a trovare \texttt{B\_Stub} fra le classi disponibili e pertanto non può essere creata \texttt{A\_Stub} e la stessa cosa vale anche per \texttt{B}.\\
Nessuna delle due classi può essere compilata, quindi, il che vuol dire che l'intero programma non può funzionare. Ovviamente, questa non è una eventualità gradita in alcuna situazione.

\begin{figure}
\centering
\includegraphics[scale=0.60]{img/circdep.eps}
\caption{\figfont modello di dipendenza circolare, senza e con classe funzione}\label{fig:cdep}
\end{figure}

La soluzione adottata in NNSec è per la verità tanto semplice ed efficace quanto spesso invisibile agli occhi di molti che perdono fin troppo tempo tentando di risolvere un problema del genere.\\
Fermandosi a riflettere, ci si accorge subito che se il server è una entità monolitica indivisibile, questo non è altrettanto vero per la componente client che può in realtà essere divisa in più parti indipendenti e egualmente funzionali. Infatti, per risolvere la questione, basta disaccoppiare il client vero e proprio dai servizi che esso offre e inglobare questi ultimi in una terza classe (che, di fatto, rappresenta una classe funzione e nient'altro) il cui riferimento sarà passato direttamente alla parte server all'atto della chiamata. Così facendo, si passa da un modello a due attori ad un modello che prevede tre attori ed elimina completamente qualsiasi dipendenza circolare (con il piacevole effetto di poter compilare e, quindi, eseguire il programma finale).\\
Il modello delle relazioni fra client e server (rappresentati rispettivamente dalle classi \texttt{CommModule} e \texttt{Worker}) prima e dopo l'aggiunta della classe funzione (nella forma della classe \texttt{Calculator}) è riportato in figura \ref{fig:cdep}.

\paragraph{Factory remota.}
Uno dei problemi principali nell'uso di RMI è rappresentato dal fatto che avendo un solo oggetto remoto (il server) in grado di offrire servizi, se questo è già impegnato nel tentativo di soddisfare una richiesta, tutte le richieste successive saranno rifiutate o, nella migliore delle ipotesi, accodate in attesa di poter essere prese in considerazione.

Questo problema è già stato discusso in sezione \ref{subsec:remfac}, ma viene qua richiamato perché rappresenta uno dei nodi cruciali per cui il modello di comunicazione prevede quattro elementi e non meno. È importante, infatti, richiamare i concetti esposti parlando del pattern Factory che, come descritto, separa il ruolo di chi svolge effettivamente i compiti demandati al server da quello di chi invece istanzia oggetti in grado di servire le richieste stesse. In questo modo, i client possono fare domanda per un oggetto ad essi associato che serva ai loro scopi, e tale richiesta sarà soddisfatta molto velocemente. A loro volta, interagendo con il riferimento assegnatoli lato server, potranno operare sugli elementi messi a disposizione dal server stesso avendo l'illusione di essere i soli ad operare nell'ambiente. In realtà, questo non accade di norma, dato che la possibilità che più client stiano accedendo nello stesso momento al server non è poi così remota in uno scenario reale, ma permette di soddisfare, quando possibile, più richieste in parallelo, abbattendo di fatto i tempi di attesa dei singoli client.

Va detto che, parlando di RMI, si aggiunge una componente ulteriore al modello, rappresentata dal registro. Infatti, una volta istanziato l'oggetto Factory, questo va posto su un registro di nomi che associ la sua posizione sulla rete (nella forma di un riferimento idoneo) ad un identificatore univoco. La richiesta dei client dovrà quindi passare attraverso il registro, il quale fornirà loro il riferimento di cui sopra (o stub) a cui essi potranno rivolgere le loro domande. Questo altro non è che un oggetto che presenta la stessa interfaccia lato server ma che incapsula al suo interno tutta una serie di dati per contattare l'elemento desiderato e un insieme di metodologie mirate all'espletamento dei servizi sulla rete.
\begin{figure}
\centering
\includegraphics[scale=0.70]{img/fourfour.eps}
\caption{\figfont i quattro moschettieri}\label{fig:four}
\end{figure}
\paragraph{}
Arrivati a questo punto, sono stati già introdotti tutti gli attori coinvolti nel modello di comunicazione adottato da NNSec. Dal problema del riferimento circolare si intuisce che tre degli attori saranno le componenti di comunicazione lato server e lato client e la classe funzione istanziata e passata dal client al server durante la chiamata (rispettivamente, le classi \texttt{Worker}, \texttt{CommModule} e \texttt{Calculator} di NNSec). In aggiunta a queste, dall'intuizione riguardante l'introduzione di una factory remota per poter soddisfare contemporaneamente più richieste, è presente un quarto elemento che crea di fatto le componenti di comunicazione lato server (le classi \texttt{Worker} di NNSec) per poter gestire in modo concorrente più richieste da parte dei client (questa è la classe \texttt{WorkerFactory} di NNSec). Il modello appena descritto è esplicitato in forma grafica in figura \ref{fig:four}.
\paragraph{}
Basandosi sugli elementi di cui sopra, la comunicazione si articola in pochi semplici passi, di seguito esposti:
\begin{itemize}
\item Il client contatta il server (o meglio, una factory remota che rappresenta la componente server); in realtà, la chiamata rispetta lo standard imposto da RMI, per cui il client contatta un registro apposito su una determinata macchina in ascolto su una specifica porta a cui potrà fare richiesta per localizzare il server che sarà, infine, contattato direttamente.
\item La componente factory istanzia un oggetto dedicato (esportandolo per renderlo visibile da oggetti remoti) a cui il client potrà fare riferimento per le sue richieste successive, e lo restituisce a quest'ultimo. Per tutta la durata della connessione, il client potrà colloquiare con il riferimento ottenuto senza dover effettuare successive richieste per ottenere ulteriori riferimenti o servizi.
\item Per poter usufruire di una rete neurale, il client farà richiesta tramite il suo oggetto dedicato che risiede sul server per riuscire a bloccare la rete neurale desiderata, recuperarne i dati sensibili e intraprendere l'elaborazione passando (dopo averlo esportato per abilitarne la visibilità remota) un riferimento remoto ad un oggetto funzione a cui il server, rappresentato dall'oggetto dedicato relativo al client, potrà fare riferimento richiedendo particolari servizi a seconda delle necessità durante l'espletamento delle sue funzioni; al termine dell'esecuzione, l'oggetto client otterrà i valori di uscita della rete neurale.
\end{itemize}
\begin{figure}
\centering
\includegraphics[scale=0.20]{img/seqdiag.eps}
\caption{\figfont diagramma di sequenza del modello di comunicazione (semplificato)}\label{fig:seqdiag}
\end{figure}
Un esempio in forma di diagramma di sequenza, semplificato rispetto all'originale, è riportato in figura \ref{fig:seqdiag}

\paragraph{}
Le quattro classi discusse, chiamate nell'ambito del progetto NNSec ``i quattro moschettieri'', rappresentano perciò il cuore del progetto, di fatto l'insieme di classi che implementano il protocollo così come descritto nel capitolo \ref{cap:one} e discusso in \cite{proto}, semplicemente appoggiandosi ad elementi di ambiente (come il gestore delle reti neurali o il parser) necessari per servizi e richieste che esulano dal protocollo stesso ma che risultano necessari.\\
Il modello di interazione fra questi elementi è il risultato di uno studio approfondito e propone in pochi elementi svariate tecniche e tecnologie, prese in prestito tanto dalla teoria quanto dagli strumenti messi a disposizione dello sviluppatore al giorno d'oggi. Il tutto ben amalgamato per raggiungere i risultati ottenuti: l'implementazione del protocollo proposto, ovvero la componente principale nonché il cuore di NNSec.
