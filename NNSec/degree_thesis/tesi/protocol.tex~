\chapter{Il Protocollo}\label{cap:one}
\epigraph{Qualunque cosa voi facciate sarà insignificante, ma è molto importante che voi la facciate}{Mahatma Gandhi}

Al giorno d'oggi esistono due grandi filoni dell'informatica in cui tanto si è fatto ma dove ancora tanto c'è da fare, in particolare il ramo della crittografia e quello dell'apprendimento automatico. Il primo rappresenta una corsa contro il tempo in cui, giorno dopo giorno, nuove tecniche vengono scoperte o raffinate e altre ancora violate, rese praticamente inutilizzabili. Nell'ambito dell'apprendimento, invece, sono stati fatti passi da gigante proprio negli ultimi decenni e le potenzialità di strumenti come le reti neurali sono ormai evidenti. L'articolo descritto in \cite{proto} rappresenta un tentativo di sposare le due cose ed è il punto di partenza del lavoro di tesi. In questo articolo è introdotto un protocollo per l'uso remoto di reti neurali che fornisca sicurezza (sarà spiegato in seguito cosa ciò significhi realmente e cosa comporti) tanto a chi mette a disposizione la rete neurale quanto a chi la sfrutta.

Lo sviluppo del software, rappresentazione concreta e finale del lavoro di tesi, si è concentrato sul protocollo proposto, cercando di sviscerarne ogni aspetto e tramutandolo in classi e relazioni fra queste. Ma lo sforzo non è stato a senso unico. Infatti, come sarà illustrato in una sezione dedicata, dalla fase di codifica ha potuto beneficiare il protocollo stesso in merito ad alcune sue sfaccettature, a seguito di alcune osservazioni sugli algoritmi coinvolti e loro conseguenti generalizzazioni.

Ovviamente, per quanto il lavoro di tesi non sia sfociato nel protocollo di seguito descritto ma sia partito da esso, è necessario dare una descrizione di quest'ultimo che permetta di capirne i retroscena, le motivazioni e i possibili utilizzi. In questo capitolo, quindi, sarà discusso il protocollo sopra citato, cercando di darne una breve ma esaustiva descrizione.

\newpage

\section{Scopo}\label{sec:aim}
Volendo dare una descrizione un po' semplicistica, le reti neurali sono un potente strumento, relativamente moderno, utile per la classificazione dei dati. Questi oggetti sono in grado di racchiudere dentro la loro struttura interna fatta di livelli intermedi nascosti un'informazione espressa in termini di pesi sui collegamenti fra i nodi componenti, così da riuscire a discriminare su un insieme di dati in ingresso assegnando loro una determinata classe. Le reti neurali vanno ovviamente create e addestrate, per poter insegnare loro come classificare i dati in ingresso ed essere quindi utilizzate allo scopo.

Il protocollo proposto su cui si è sviluppato il lavoro di tesi, discusso in \cite{proto}, propone un modello in cui due entità indipendenti desiderano l'una di mettere a disposizione una rete neurale (quindi, prendendosi anche il compito di crearla e allenarla) e l'altra di sfruttare il servizio offerto. La necessità, però, è che ciò avvenga in sicurezza. Cosa realmente significhi questa parola, poi, sarà ampiamente discusso.\\
L'idea alla base di questo nuovo protocollo è quella di non affidarsi alle soluzioni generiche per SMC (Secure Multi-Party Computation) per la computazione, come discusse in \cite{yao1982psc} e \cite{goldreich1987pam}, ovvero cercare di evitare di ricorrere a tecniche che introducessero nel protocollo stesso un alto grado di interazione fra le parti. Infatti, SMC mira a risolvere problematiche che coinvolgono più attori, senza ricorrere ad una terza parte ma piuttosto utilizzando protocolli che prevedono un alto grado di collaborazione fra i diversi soggetti. Queste tecniche si sono rivelate piuttosto inefficienti quando applicate a specifiche situazioni come quella in esame. Infatti, per loro stessa natura, impongono una decisa collaborazione fra client e server per la computazione delle funzioni di attivazione o uscita di un nodo e, di conseguenza, un alto carico in termini di tempo, memoria e banda spese per ottenere il risultato. Piuttosto, questo protocollo cerca di introdurre un modello che limiti le interazioni fra client e server, basandosi su tecniche di cifratura che presentano proprietà omomorfiche così da permettere di ottenere direttamente tramite operazioni nel dominio cifrato tutte le computazioni lineari. Per le funzioni non lineari, invece, come già accennato, bisogna ricorrere obbligatoriamente ad una interazione fra le parti.\\
Tutto ciò è ottenuto in modo da assicurare due cose:
\begin{itemize}
\item chi mette a disposizione la rete neurale potrà contare sul fatto che la sua conoscenza rimarrà privata e non sarà diffusa permettendone duplicati; in altri termini, l'attenzione è focalizzata nel tentativo di evitare che un ipotetico attaccante possa ricostruire la rete neurale messa a disposizione per l'uso remoto semplicemente sottoponendo ad essa determinati input e risalendo dai risultati ottenuti alla struttura interna della rete stessa
\item chi sfrutta la rete neurale messa a disposizione avrà la certezza che i suoi dati non siano diffusi o scoperti, dove per dati si intendono i valori di ingresso e di uscita della rete neurale e non altri dati potenzialmente sensibili come i dati anagrafici; si possono immaginare i dati sottoposti alla rete neurale come descrizione di sintomi e il risultato ottenuto come una conferma o meno sul fatto che l'utente abbia una malattia grave: esistono allora molti casi già in questo semplice esempio in cui occultare tali dati può risultare molto importante dal punto di vista dell'utente
\end{itemize}
Nel primo caso, quindi, è protetto l'investimento fatto da chi crea e addestra la rete neurale e non vuole che terzi possano ottenerne una copia identica a partire da quella proposta e da un'analisi del suo comportamento. Nel secondo caso, invece, sono protette le informazioni relative all'utente remoto di tali reti neurali, ovvero sono occultati i valori sottoposti in ingresso ad esse e i risultati ottenuti.

\section{Mattone su mattone}
Prima di descrivere nei particolari il protocollo proposto, è necessario parlare di alcuni aspetti di contorno utili per poter capire al meglio quanto sarà detto. Questa sezione, quindi, presenta tutto ciò che può essere pensato come le fondamenta, o meglio l'insieme di mattoni con cui il protocollo stesso sarà costruito, mattone dopo mattone.

\subsection{Reti neurali}\label{subsec:nn}
Esistono svariati tipi di rete neurale, ognuna adatta a scopi più o meno specifici e modellabile secondo necessità. Per approfondimenti su tale argomento e sull'apprendimento automatico in generale, si consiglia la lettura di \cite{RussellNorvig} e \cite{Mitchell}. Di seguito saranno illustrate le diverse tipologie di reti neurali interessate dal protocollo proposto e che con quest'ultimo possono essere utilizzate realmente e praticamente.\\
Prima di tutto, si osservi che le reti neurali sono potenti strumenti per la classificazione dei dati e permettono di modellare un gran numero di funzioni conosciute o meno. Al giorno d'oggi è noto che, dal punto di vista teorico, una rete neurale può approssimare con precisione arbitraria un insieme molto ampio di funzioni, a seconda della struttura interna della rete neurale utilizzata, del numero di livelli intermedi e del numero di nodi in essi presenti. Queste reti sono spesso fornite con buoni algoritmi di apprendimento, hanno un'alta resistenza al rumore e generalizzano in modo corretto su un gran numero di esempi non visti, risultando ottimi strumenti per riuscire a descrivere anche funzioni sconosciute. Si può infatti pensare ad una rete neurale come ad una scatola nera che in base ai processi di apprendimento modella al suo interno una serie di relazioni fra i nodi, così da essere in grado di riprodurre le funzioni che hanno generato i dati proposti in queste fasi. Potenzialmente, quindi, questi oggetti possono anche arrivare ad approssimare con una certa precisione fenomeni descritti da funzioni al momento sconosciute all'uomo, ma di cui quest'ultimo conosce gli ingressi e le uscite senza essere ancora riuscito a ricavare o dimostrare una relazione valida fra di essi.

Esistono comunque vari tipi di reti neurali e non tutte sono utilizzabili con il protocollo sviluppato in NNSec. In particolare, possono essere utilizzati solo percettroni e reti neurali di tipo feed-forward, descritte di seguito. Nella pratica possono essere descritte un numero molto maggiore di reti neurali rispetto a quelle che NNSec è realmente in grado di trattare, grazie alla grammatica sviluppata per descrivere tali oggetti, ma il fatto che una rete neurale si possa sottoporre in ingresso al software non implica necessariamente che questa si comporti come atteso una volta utilizzata.

\paragraph{Percettrone.}
Il percettrone, riportato in figura \ref{fig:perc} è una delle reti neurali più elementari. Non presenta livelli intermedi, ma solamente un insieme di nodi di ingresso collegati a loro volta ad un nodo di uscita, direttamente. Questo modello può in realtà anche essere generalizzato aggiungendo più nodi di uscita, ma la trattazione sarà fatta sul modello con singolo nodo di uscita senza perdere di generalità.\\
\begin{figure}
\centering
\includegraphics[scale=0.55]{img/perceptron.eps}
\caption{\figfont il percettrone}\label{fig:perc}
\end{figure}
Il percettrone può discriminare fra due classi di appartenenza, approssimando funzioni che di fatto classificano gli ingressi associandoli ad una classe piuttosto che ad un'altra. Il valore di uscita è calcolato come combinazione lineare dei valori in ingresso pesati in base ai valori presenti sui collegamenti fra nodi. Il valore così ottenuto può essere ulteriormente elaborato tramite l'uso di una funzione di attivazione detta $ g $, come ad esempio la funzione sigmoide o la funzione segno. Quindi, il valore sul nodo terminale non sarà necessariamente la combinazione lineare dei valori pesati in ingresso, a meno che la funzione di attivazione non sia rappresentata dall'identità.\\
La forma matematica per il discriminante (ovvero il valore associato al nodo di uscita prima dell'elaborazione) è data dalla seguente espressione: $ a(x) = \bar{w}^T\bar{x} + w_0 $ , dove $ \bar{x} $ rappresenta il vettore di ingresso e $ \bar{w} $ il vettore dei pesi sui collegamenti, mentre $ w_0 $ è la soglia associata al nodo. Per ottenere il valore realmente associato al nodo di uscita, basta applicare al discriminante la funzione di attivazione $ g $, ovvero ricavare: $ g(a) $. L'uscita è associata alla classe $ c_1 $ se $ g(a) \geq w_0 $, oppure alla classe $ c_2 $ se $ g(a) < w_0 $. In realtà, il valore $ w_0 $ può essere inglobato nei vettori $ \bar{x} $ e $ \bar{w} $, ottenendo due vettori alternativi $ \bar{x}' = [\bar{x}\mid 1]^T $ e $ \bar{w}' = [\bar{w}\mid w_0]^T $, da cui si ottiene $ a(x) = \bar{w}'^T\bar{x}' $; in questo caso, la soglia che discrimina nell'associazione dei valori in ingresso ad una classe piuttosto che ad un'altra è data dal valore $ 0 $. In caso esista la necessità di trattare con più classi di appartenenza, ovvero nei casi in cui siano presenti più nodi di uscita, il metodo può essere facilmente generalizzato ripetendo quanto illustrato sopra per ogni nodo di uscita del percettrone.

\paragraph{Reti Feed-Forward}
Il percettrone ha molte limitazioni, la più importante delle quali è che esso non riesce ad operare correttamente su insiemi di dati che non siano linearmente separabili in due classi di appartenenza, come ad esempio la funzione \textit{xor}. Da queste limitazioni nascono le reti feed-forward con un numero arbitrario di livelli intermedi nascosti, riportate in figura \ref{fig:nn}.\\
\begin{figure}
\centering
\includegraphics[scale=0.45]{img/nn.eps}
\caption{\figfont rete neurale feed-forward}\label{fig:nn}
\end{figure}
Nelle reti di tipo feed-forward la propagazione dei segnali avviene unicamente, in maniera continua, nella direzione che conduce dagli ingressi alle uscite, mentre nelle reti ricorrenti (non feed-forward) tale propagazione può anche manifestarsi da uno strato neurale successivo ad uno precedente, oppure tra neuroni appartenenti ad uno stesso strato, e persino tra un neurone e sé stesso, generando quindi cicli. Le reti feed-forward, invece, si caratterizzano proprio per l'assenza di cicli. In questi tipi di rete, i nodi si dividono in tre categorie: nodi di ingresso, ovvero i nodi che ricevono i valori di ingresso dall'esterno; nodi di uscita, ovvero i nodi che presentano il risultato dell'elaborazione; nodi nascosti, tutti i nodi che non sono né di ingresso né di uscita. Ogni nodo poi riceve collegamenti da nodi appartenenti a livelli precedenti, ad eccezione ovviamente dei nodi di ingresso, e propone collegamenti diretti verso nodi che risiedono in livelli successivi, ad eccezione dei nodi di uscita; nessun altro tipo di collegamento è permesso. Immaginando di numerare in ordine crescente i nodi (come evidenziato in figura \ref{fig:nn}), si possono descrivere le reti feed-forward come quelle reti in cui ogni nodo $ n $ riceve collegamenti provenienti solo da nodi con indice $ m $ tale che $ m < n $ e propone collegamenti esclusivamente verso nodi con indice $ h $ tale che $ h > n $. Queste direttive, seppure pongano limiti sulla libertà di strutturare una rete a piacimento, permettono di avere modelli più facilmente analizzabili tanto in linea teorica che all'interno di un software.\\
Il valore associato al $ j $-esimo nodo nascosto appartenente all'$ i $-esimo livello intermedio è ottenuto ricavando prima di tutto la combinazione lineare degli $ l $ valori in ingresso pesati a seconda dei valori di collegamento, ovvero:
$$ a_j^{(i)} = \sum^l_{k = 1}w_{jk}^{(i)}x_k $$
In questo caso, $ w_{jk}^{(i)} $ indica il peso associato all'arco proveniente dal $ k $-esimo nodo appartenente al livello precedente a $ i $ e diretto al $ j $-esimo nodo del livello $ i $. Come per il percettrone, i singoli nodi possono avere una funzione di attivazione e/o di uscita, anche immaginabile come funzione unica associata al singolo nodo e detta $ g $. Il valore risultante per il nodo in questione, ottenuto dalla computazione del valore associato a tale nodo, è ricavato come segue:
$$ z_j^{(i)} = g\left( a_j^{(i)}\right) $$
Ovviamente, iterando su tutti i nodi nascosti fino a raggiungere i nodi di uscita e applicando lo stesso procedimento anche a quest'ultimi, si ottiene il risultato finale della computazione all'interno della rete neurale.

\paragraph{Funzioni.}
Per quanto riguarda le funzioni di attivazione dei singoli nodi, queste sono solitamente un insieme limitato e ben definito comprendente quelle che meglio si adattano allo scopo.
\paragraph{}
Fra le più usate, la funzione sigmoide, ovvero:
$$ f(a) = \frac{1}{1 + e^{-a}} $$
Il termine sigmoide significa ``a forma di S''. Questa funzione conduce  dall'intervallo $ (-\infty, \infty) $ in $ (0, 1) $, come riportato in figura \ref{fig:sigmoid}, la quale mette meglio in evidenza anche la natura stessa del suo nome.
\begin{figure}
\centering
\includegraphics[scale=0.65]{img/sigmoid.eps}
\caption{\figfont funzione sigmoide}\label{fig:sigmoid}
\end{figure}
Si osservi che nei casi in cui il parametro $ a $, ovvero la somma lineare dei valori pesati in ingresso al nodo, si mantiene all'interno di un intervallo limitato intorno allo zero, questa funzione approssima una funzione lineare e rende i singoli nodi molto sensibili alle piccole variazioni. Invece, per valori di $ \vert a \vert $ superiori ad una certa soglia, la funzione sigmoide risulta quasi completamente insensibile alle variazioni, dato che essa presenta due asintoti orizzontali per $ a\rightarrow\pm\infty $
\paragraph{}
Un'altra funzione spesso usata è la funzione segno, o funzione di Heaviside, anche definita come segue:
$$ sign (x) = \left\{
\begin{matrix}
-1, & x < 0 \\
0, & x = 0 \\
+1, & x > 0
\end{matrix}
\right. $$
Questa funzione non è particolarmente complessa e si limita ad estrapolare il segno del suo valore in ingresso, permettendo di rappresentare l'intervallo $ (-\infty, \infty) $ attraverso i soli valori appartenenti all'insieme $ \left\{-1, 0, 1\right\} $.\\
La funzione segno viene spesso usata come funzione di attivazione per il percettrone, dove si discrimina fra classi di appartenenza a seconda che il valore associato al nodo di uscita sia maggiore o minore di zero come spiegato in questa stessa sezione.
\paragraph{}
Ci sono decine di funzioni utilizzate durante l'allenamento e l'uso di reti neurali e le due descritte sopra sono solo alcuni esempi delle più diffuse. Inoltre, la funzione segno e la funzione sigmoide sono anche le uniche due funzioni supportate in NNSec per il calcolo dei valori di attivazione dei nodi, grazie alle loro caratteristiche di anti-simmetria che le rendono particolarmente interessanti come illustrato in sezione \ref{subsec:req}.

\subsection{Requisiti dell'applicazione}\label{subsec:req}
Lo scenario considerato nel protocollo è quello in cui due utenti, Alice e Bob, dispongono rispettivamente di un insieme di dati e di un classificatore (ovvero, una rete neurale adeguatamente creata e addestrata). Alice è interessata alla classificazione dei propri dati sulla base delle conoscenze acquisite da Bob.

Sono da tralasciare, in quest'ottica, le soluzioni che prevedono l'invio da parte di Alice dei suoi dati a Bob per la classificazione e, viceversa, l'invio da parte di Bob della rete neurale ad Alice. Infatti, se da un lato Alice non gradirebbe rivelare i dati coinvolti (intesi come valori di ingresso e di uscita della rete neurale) a Bob, così quest'ultimo non gradirebbe uno sforzo da parte di Alice mirato a rivelare la struttura della rete neurale in modo da duplicarla (si suppone infatti che Bob abbia speso tempo e denaro per preparare la sua rete), come spiegato in sezione \ref{sec:aim}. Allo stesso modo, è da escludere il caso in cui si preveda l'utilizzo di una terza parte fidata (anche detta TTP, Trusted Third Party) che prelevi la rete neurale da Bob e i dati di ingresso da Alice per restituire infine il risultato ottenuto a quest'ultima: sarà difficile trovare un terzo elemento fidato per entrambi laddove Alice e Bob non si fidano l'un l'altro.\\
Lo scopo del protocollo è la classificazione remota dei dati che rispetti i vincoli sopra descritti ricorrendo a tecniche di crittografia che sopperiscano alla mancanza di una terza parte fidata. Come altri protocolli presenti in letteratura, anche questo si basa sul fatto che tanto Bob quanto Alice siano semi-onesti, ovvero seguano correttamente il protocollo ma possano allo stesso tempo analizzarlo in corso d'opera cercando di recuperare informazioni riguardanti l'altra parte coinvolta. Si suppone anche che Alice e Bob stiano comunicando attraverso un canale sicuro (privato e autenticato).

Di seguito è riportata una lista dei requisiti richiesti da un protocollo del genere, dove viene anche indicato se quello proposto come base del lavoro di tesi soddisfa il punto in questione o meno.

\paragraph{Correttezza.}
Ciò significa che Alice desidera avere una corretta classificazione in merito ai propri dati. Questo, nel protocollo proposto, non è possibile assicurarlo in alcun caso. Infatti, se Bob prevede di classificare i dati non solo in base alle informazioni in essi contenute ma anche in base ad altri fattori esterni, niente può fare il protocollo per correggere il risultato o rivelare il tentativo di falsificazione. In altri termini, se la rete neurale messa a disposizione da Bob non si comporta come dovrebbe perché manomessa, il protocollo non potrà fare fronte a questa tipologia di situazioni. A seguito di questa eventualità altre tecniche dovrebbero essere introdotte per porre rimedio, come ad esempio la possibilità di ricorrere a prove di Zero-Knowledge (descritte in \cite{goldreich2001fcb}) per assicurare che ogni passaggio sia svolto correttamente.
\begin{itemize}
\item \textit{Sicurezza per Alice.} I dati di Alice sono completamente al sicuro. In realtà, i valori forniti da Alice sono in forma cifrata ed essa riceve a sua volta un risultato ancora in forma cifrata. Inoltre, in nessun momento durante l'interazione fra Bob e Alice, il primo ha modo di accedere ad una forma originale o composita dei dati che non sia cifrata e tutti i punti del protocollo che prevedono una decifratura dei dati impongono anche che questa sia messa in pratica da Alice che, a sua volta, cifrerà nuovamente tali dati prima di restituirli a Bob. Quindi, la sicurezza di Alice risiede in quella del cifrario sottostante.
\item \textit{Sicurezza per Bob.} Per quanto riguarda Bob, la sicurezza dal suo punto di vista consiste nel proteggere la propria esperienza racchiusa nella rete neurale offerta. Di conseguenza, ciò che sta a cuore a Bob è il non rivelare la struttura della rete neurale, riuscendo così ad impedirne la riproduzione da parte di terzi. Infatti, supponendo che Alice possa eseguire un numero arbitrario di volte il protocollo, essa può scoprire informazioni importanti sulla conformazione della rete neurale sottoponendo alla rete degli ingressi specifici e, quindi, può potenzialmente riprodurre la rete neurale di Bob. Questo discende dal fatto che a partire dagli ingressi e dal risultato di una determinata computazione si può sempre scoprire qualcosa in merito alla funzione coinvolta (questo è ciò su cui si basa la teoria delle reti neurali, del resto). Una buona domanda, in ogni caso, è quante interazioni siano necessarie per poter risalire alla struttura interna della rete.\\
A questo proposito è interessante focalizzarsi su cosa può essere importante proteggere dal punto di vista di Bob, per rendere difficile se non impossibile la violazione della sua conoscenza.
\item \textit{Struttura.} Una rete neurale feed-forward è composta da un certo numero di nodi connessi fra loro, come descritto in sezione \ref{subsec:nn}. Il protocollo è pensato per proteggere completamente il modo in cui i neuroni sono connessi e parzialmente anche il loro numero, così che Alice possa solo venire a conoscenza di un limite superiore $ B $ di questo numero. Il valore di $ B $ può essere impostato da Bob per rendere allo stesso tempo efficiente e sicuro dal suo punto di vista il protocollo stesso. In ogni caso, la necessità di sicurezza da parte di Bob incide inevitabilmente sulle prestazioni del protocollo.
\item \textit{Risultato dei nodi nascosti.}
Potrebbe essere utile nascondere il risultato delle computazioni intermedie sui nodi nascosti, utili a raggiungere il risultato finale. Dato un nodo con una funzione di attivazione sigmoidale, è possibile quindi dividere il risultato in due parti, una che può essere completamente protetta, mentre l'altra sarà parzialmente rivelata. Le due parti sono:
\begin{itemize}
\item \textit{Stato del neurone.} In relazione al segno della somma pesata degli ingressi, ogni neurone può essere attivo o meno. questa informazione può essere completamente nascosta, variandola con probabilità al cinquanta per cento. In altri termini, è possibile cambiare con cadenza non definita a priori il segno di tale valore così da farlo apparire completamente casuale ad Alice.
\item \textit{Valore associato.} Il parametro di attivazione relativo ad ogni neurone ha anche un valore oltre che un segno, il quale dà informazione su quanto un determinato nodo sia realmente attivo o meno. Questo valore non sarà protetto, ma Alice non avrà modo di capire quale neurone sia legato ad uno specifico parametro. Infatti, questa informazione sarà occultata attraverso tecniche di permutazione dei nodi intermedi, come illustrato in seguito.
\end{itemize}
\end{itemize}

\paragraph{Complessità di interazione.}
Ogni scenario ideale per situazioni del genere non prevede alcuna interazione fra le parti. Questo non è il caso del protocollo proposto, che invece presenta una complessità costante dovuta alle interazioni necessarie. In particolare, sono presenti interazioni fra Alice e Bob in quantità strettamente proporzionale al numero dei livelli intermedi, alla luce del fatto che per ogni singolo nodo potrebbe esserci la necessità di computare un valore di attivazione e/o di uscita (operazione che necessariamente deve essere portata a termine da Alice). Sotto quest'ottica, è possibile dire che il numero di interazioni è lineare rispetto al numero di livelli intermedi e cresce in modo proporzionale a quest'ultimo.

\subsection{Il cifrario}\label{subsec:cip}
Dietro a un grande protocollo che mira a conseguire la sicurezza, risiede un grande cifrario. In questo caso, un cifrario risultato dallo sforzo congiunto di più persone quali Paillier, Damg\aa rd e Jurik. Per approfondimenti sull'argomento, sono consigliate le letture di \cite{paillier} e \cite{brics}, dove viene analizzato dal punto di vista matematico il cifrario e alcune modifiche ad esso applicabili, insieme ad un'ampia discussione che analizza e approfondisce lo studio della complessità.\\
Di seguito, saranno discussi gli aspetti più interessanti relativi al cifrario utilizzato.
\paragraph{Setup.}
Per l'implementazione del protocollo proposto è necessario uno schema di cifratura a chiave pubblica/privata con proprietà omomorfiche e probabilistiche. La sceltà è ricaduta sulla versione modificata da Damg\aa rd-Jurik (proposta in \cite{brics}) dello schema di cifratura di Paillier (discusso in \cite{paillier}. Questo cifrario è basato sulla difficoltà nello scoprire il residuo $ n $-esimo di un elemento in modulo $ n^{s + 1} $, dove $ n $ è un modulo RSA. Di fatto, la difficoltà nel rompere una determinata chiave è legata alla difficoltà nella fattorizzazione di numeri molto grandi. Per approfondimenti sugli argomenti legati alla crittografia, fare riferimento a \cite{goldreich2001fcb} e \cite{goldreich2004fci}.\\
Per ottenere ciò, è richiesta una fase di pre-elaborazione in cui vengono stabiliti alcuni parametri fondamentali. In particolare, sono selezionati due numeri primi $ p $ e $ q $ sufficientemente grandi da cui è calcolato il prodotto $ n = pq $ che rappresenta la chiave pubblica; la chiave privata, invece, detta $ \lambda $, è data dal minimo comune divisore tra $ (p - 1) $ e $ (q - 1) $.
\paragraph{Cifratura.}
Sia $ m \in \mathbb{Z} $ il testo in chiaro e $ s $ tale che $ n^s > m $, sia $ r $ un valore casuale tale per cui $ r \in \mathbb{Z}^*_{n^s} $ (ovvero $ r $ è compreso nell'insieme dei valori appartenenti a $ \mathbb{Z} $ e relativamente primi con $ n^s $), la versione cifrata $ c $ di $ m $ è data dalla formula:
$$ c = E_{pk} (m, r) = (1 + n)^mr^{n^s}\;mod\;n^{s + 1} $$
\paragraph{Decifratura.}
La funzione di decifratura $ D_{sk} $, invece, dipende solamente dal testo cifrato e non c'è bisogno di conoscere il valore casuale $ r $ in questa fase. Ovviamente, solo il possessore della chiave privata potrà risalire al testo in originale. Per chiarimenti sulla fase di decifratura, si faccia riferimento a \cite{paillier} e \cite{brics}.
\paragraph{}
Uno dei grossi vantaggi del cifrario utilizzato è dato dal fatto che solamente il parametro $ n $ deve essere fissato, mentre $ s $ può essere aggiustato in base al testo in chiaro. In altre parole, diversamente da molti cifrari dove bisogna scegliere la dimensione del testo in chiaro imponendola minore di $ n $, in questo caso si può scegliere $ m $ arbitrariamente grande e quindi operare su $ s $ per fare in modo che sia $ n^s > m $. Questo ovviamente si ripercuote sul protocollo traducendosi in una maggiore libertà sulla scelta della dimensione dei valori $ m $.
\paragraph{Proprietà omomorfiche.} 
Come detto, il cifrario proposto soddisfa alcune proprietà omomorfiche che possono rappresentare, a seconda dei punti di vista, un aspetto problematico o interessante di un sistema crittografico. In questo caso, come si può capire, la cosa è ben voluta.\\
Supponendo di avere due elementi in chiaro detti $ m_1 $ e $ m_2 $, indicando con $ E(m) $ la cifratura del messaggio in chiaro $ m $ e con $ D(c) $ la sua decifratura, sono soddisfatte le seguenti uguaglianze:
$$ D (E (m_1)\cdot E (m_2)) = m_1 + m_2 $$
$$ D (E (m)^a) = am $$
La disponibilità di uno schema crittografico con proprietà omomorfiche è interessante dal punto di vista della possibilità di effettuare operazioni lineari nel dominio in chiaro operando direttamente nel dominio cifrato. In particolare, operazioni di moltiplicazione ed elevamento a potenza effettuate nel dominio cifrato si traducono, una volta decifrato il dato ottenuto, nel risultato di operazioni lineari come la somma e la moltiplicazione di valori effettuate nel dominio di partenza. Questo aspetto non è da sottovalutare perché permette di computare determinati valori senza dover ricorrere a fasi di decifratura e cifratura che appesantirebbero il calcolo (non è da trascurare però la complessità derivante dal fatto di operare con numeri molto grandi).
\paragraph{Influenza del cifrario sui nodi.}
Le proprietà del cifrario sopra descritte si rivelano molto utili, come già accennato, in alcune fasi della computazione lato server. In particolare esiste la possibilità di calcolare il valore associato al singolo nodo, dato dalla somma pesata dei valori presenti sui nodi collegati in ingresso, senza dover ricorrere a fasi di decifratura e conseguente nuova cifratura dei dati. Quindi, la computazione può avvenire nel dominio cifrato.\\
Brevemente, bisogna ricordare che laddove sia $ \bar{x} $ un vettore contenente i valori dei nodi collegati in ingresso e $ \bar{w} $ il vettore contenente i pesi rispettivamente associati ai collegamenti presenti (entrambi i vettori hanno in questo caso pari lunghezza $ l $), il valore relativo al singolo nodo è dato da:
$$ a = \sum^l_{k = 1}w_kx_k $$
Supponendo ora che sia $ c $ la versione cifrata del vettore $ \bar{x} $ (ovvero, il vettore in cui ogni componente è cifrata singolarmente) e sia $ \bar{w} $ come sopra, grazie alle proprietà omomorfiche discusse si può ottenere una versione cifrata $ d $ di $ a $ calcolata operando in dominio cifrato e la cui decifratura restituisce lo stesso valore $ a $ sopra computato in chiaro. Questo è possibile come indicato di seguito:
$$ d = \prod^l_{k = 1}c_k^{w_k} $$
Infatti, si può ricavare dalle proprietà discusse:
$$ a = D(d) = D\left(\prod^l_{k = 1}c_k^{w_k}\right) = D\left( E(x_1)^{w_1} \cdot ... \cdot E(x_l)^{w_l}\right) = x_1\cdot w_1 + ... + x_l\cdot w_l $$
Questo risvolto è ovviamente molto utile perché concorre a limitare le interazioni fra client e server permettendo a quest'ultimo di calcolare i valori associati ai singoli nodi senza dover ricorrere ai servizi offerti dalla controparte, utilizzati invece per calcolare a partire da $ d $ i valori rispettivamente di attivazione e/o uscita del nodo.

\section{Protocollo}\label{sec:proto}
A questo punto, esistono e sono state discusse tutte le premesse e le componenti utili per la costruzione di un protocollo che permetta l'uso di reti neurali remote e consegua allo stesso tempo i requisiti citati. Adesso è finalmente possibile esporre i modelli di elaborazione del valore finale, ovvero come sarà effettivamente usata la rete neurale.

\subsection{Percettrone}
Il percettrone è una delle reti più semplici che si possono concepire e, nella sua versione base, è composto da $ I $ neuroni di ingresso e un solo neurone di uscita. La descrizione che segue coprirà questa struttura basilare ma può facilmente essere estesa a percettroni con un numero $ O $ di neuroni di uscita semplicemente eseguendo in parallelo $ O $ istanze del protocollo.\\
L'algoritmo per il valore di uscita del percettrone prevede come ingressi un vettore $ \bar{c} = E\left(\bar{x}\right) $ fornito da Alice, dove $ \bar{x} $ rappresenta il vettore dei valori in ingresso in chiaro e $ \bar{c} $ la loro versione cifrata. Inoltre, è presente un vettore $ \bar{w} $ messo a disposizione da Bob e rappresentante i pesi associati ai collegamenti fra i nodi di ingresso e il nodo di uscita. Il protocollo si articola nei seguenti pochi passi:
\begin{itemize}
\item Bob calcola il valore $ d $ associato al nodo di uscita, come descritto nelle sezioni precedenti, ottenendo un valore cifrato che rappresenta appunto il risultato della computazione. Questo valore viene inviato ad Alice.
\item Alice decifra il valore di uscita della rete, ovvero calcola: $ a = D(d) $ .
\item Alice computa $ g(a) $, supponendo che $ g $ rappresenti la funzione di attivazione e/o uscita del nodo. Laddove siano presenti entrambe le funzioni, ovviamente, $ g $ può essere pensata come una funzione unica, combinazione delle due citate.
\end{itemize}
Questo modello, seppure tanto completo quanto semplice, è di scarsa utilità e non permette di conseguire sicurezza dal punto di vista di Bob. Del resto, è improbabile che un percettrone riesca ad approssimare funzioni per cui si voglia fornire un servizio remoto di classificazione, come anche rara è l'ipotesi che qualcuno impieghi grosse quantità di tempo e denaro per allenare un percettrone. Questa eventualità è quindi da pensare più che altro come un campo di prova del protocollo o una sua estensione ad una tipologia di reti che si presta comunque ad un corretto funzionamento.

\subsection{Reti neurali multi-livello}\label{subsec:nnff}
Le reti neurali feed-forward che presentano uno o più livelli nascosti utilizzano un algoritmo leggermente diverso e un po' più complicato. Riassumendo, una singola rete neurale feed-forward con uno o più livelli nascosti è composta da $ N $ neuroni ordinati in modo che ogni neurone $ j $ riceva collegamenti in ingresso solo da nodi con indice $ i $ tale che $ i < j $ e viceversa proponga collegamenti in uscita verso nodi con indice $ k $ tale che $ k > i $. Questa numerazione può essere usata per ordinare i singoli nodi, come evidenziato anche in figura \ref{fig:nn}. I collegamenti fra un nodo $ i $-esimo e un nodo $ j $-esimo sono indicati come $ w_{ij} $. Il vettore di valori in ingresso al singolo nodo $ j $-esimo è detto $ x_j $ mentre il vettore dei pesi associati è indicato come $ w_j $ (ovviamente, il peso $ n $-esimo è associato al valore $ n $-esimo in ingresso al nodo).\\
Per poter spiegare al meglio l'algoritmo per questo tipo di reti, bisogna introdurre prima alcune tecniche utili a Bob per riuscire ad offuscare i dati (come dettato dai requisiti esposti). 
\paragraph{Protezione del valore associato ai neuroni nascosti.}
Nel protocollo per il percettrone, Bob fornisce ad Alice il valore $ d $ che rappresenta la somma lineare pesata $ a $ dei valori in ingresso e Alice calcola localmente il valore di attivazione/uscita. Questo può essere ovviamente ripetuto per ogni nodo componente la rete neurale nel caso di rete neurale feed-forward con uno o più livelli nascosti. Bisogna però rendere più sicura la cosa, così da confondere le idee ad una potenziale Alice nel caso in cui questa nutra l'intenzione di duplicare la rete.\\
\begin{figure}
\centering
\includegraphics[scale=0.65]{img/ssigmoid.eps}
\caption{\figfont anti-simmetria della funzione sigmoide}\label{fig:ssigmoid}
\end{figure}
Il valore $ a $ può essere pensato come composizione: $ a = sign(a)\cdot\vert a\vert $. In relazione al segno di $ a $, si può notare che il grafico della funzione sigmoide è perfettamente anti-simmetrico, come riportato in figura \ref{fig:ssigmoid}, e così anche quello della funzione segno. Ciò significa semplicemente che: $g(-a) = 1 - g(a) $. Questo è un buon punto di partenza per riuscire a proteggere l'informazione sul segno di $ a $, o almeno per fare un tentativo in questa direzione.\\
Con questi presupposti, Bob può scegliere in maniera del tutto casuale di cambiare il segno ad $ a $ prima di inviare il valore ad Alice, anche grazie alle proprietà omomorfiche del cifrario. Semplicemente, basta notare che: $ E(a)^{-1} = E(-a) $, dove $ E(x) $ rappresenta il valore ottenuto dalla cifratura di $ x $. Così facendo Alice può decifrare ed elaborare i dati come di consueto, però ciò che restituirà a Bob non sarà più la cifratura di $ g(a) $ ma bensì quella di $ g(-a) $, ovvero $ E(g(-a)) $. A questo punto, sempre in base alle proprietà sia della funzione sigmoide che del cifrario utilizzato, Bob potrà recuperare ciò a cui è interessato effettuando semplicemente una sottrazione, infatti:
$$ E(g(a)) = E(1 - g(-a)) = E(1)E(g(a))^{-1} $$
In questo modo le idee di Alice sono un po' più confuse ed ella non sa quale neurone è realmente attivo o meno. Del resto, questa intuizione è applicabile solamente alle funzioni segno e sigmoide, ma non vale in generale per qualsiasi funzione. Ciò nonostante, proprio queste due funzioni sono quelle coinvolte nel protocollo proposto e, laddove vi sia la necessità di operare con altre funzioni, esisterà allo stesso modo il bisogno di concepire nuove metodologie di occultamento. In ogni caso, nell'ambito delle reti neurali le funzioni più largamente utilizzate per il calcolo del valore di attivazione sono proprio la funzione segno e la funzione sigmoide che, come indicato, si prestano alle tecniche di cui sopra.
\paragraph{Occultamento della rete neurale.}
Un altro aspetto da proteggere è la topologia della rete, ovvero il numero di neuroni presenti e il modo in cui questi sono connessi fra loro. Intuitivamente, ciò è applicabile solamente ai livelli intermedi in quanto non avrebbe senso voler nascondere numero e disposizione dei neuroni di ingresso o di uscita.\\
L'idea alla base dell'occultamento della struttura di una rete neurale consiste nell'inserire tale oggetto all'interno di una rete composta da $ L $ livelli e $ M_i $ nodi per ciascun livello, dove ovviamente sia $ \sum_iM_i > N $, con $ N $ numero di nodi della rete originale. In questo modo vengono aggiunti $ \sum_iM_i - N $ neuroni fittizi, del tutto somiglianti ai neuroni originali, connessi con questi tramite collegamenti in ingresso dal peso casuale ma senza alcun collegamento in uscita diretto ai neuroni della rete incapsulata. Così facendo, i neuroni fittizi non influenzeranno in alcuno modo il comportamento originale della rete neurale. Ovviamente, comportandosi come neuroni reali ed essendo soggetti alle stesse leggi, anch'essi riceveranno collegamenti in ingresso solo dai nodi appartenenti a livelli precedenti e proporranno collegamenti in uscita solo verso nodi (in questo caso esclusivamente fittizi) appartenenti a livelli successivi.\\
In questo modo Alice riuscirà ad ottenere solo un limite superiori $ \sum_iM_i $ del numero di nodi reale $ N $ e non riuscirà a capire il modo in cui questi sono connessi o, ancora, i pesi associati alle connessioni. Inoltre, $ L $ indica anche un limite riguardo alla lunghezza del percorso presente fra i nodi di ingresso e quelli di uscita. Un incremento dei valori $ L $ e $ M_i $ proteggerà meglio la topologia della rete, ma non bisogna trascurare in questo caso anche il fatto che ciò incide in maniere notevole sulle prestazioni, aumentando di fatto il carico computazionale e il numero di interazioni fra le parti.
\paragraph{Permutazione.}
L'unica cosa rimasta realmente da proteggere è il valore di $ \vert a\vert$, che rischia di essere rivelato, insieme al peso associato ai collegamenti, dall'applicazione ripetuta del protocollo da parte di Alice, come evidenziato in sezione \ref{sec:aim}. Ovviamente, questa è una situazione potenzialmente pericolosa e bisognerebbe possibilmente evitarla.\\
La soluzione proposta è quella di permutare la posizione dei singoli neuroni all'interno di un livello. Infatti, basandosi sulle proprietà delle reti feed-forward, è dimostrabile che questa operazione non influisce in alcun modo sul risultato finale. Bisogna sottolineare che le permutazioni valide possibili sono solamente quelle che mantengono la posizione in termini di livello di appartenenza del nodo. Anche in questo caso, agendo sui parametri citati si incrementa il numero di possibili differenti permutazioni valide ma, di contro, anche la complessità computazionale dell'intero processo.\\
Come spesso accade, la sicurezza ha un prezzo in termini di tempo di calcolo e risorse utilizzate per il suo conseguimento.
\paragraph{}
Finite le dovute osservazioni sui vari aspetti coinvolti nell'algoritmo relativo alle reti neurali multi-livello, è possibile presentare finalmente la soluzione proposta nel protocollo commentandola passo dopo passo. Ovviamente, prima di tutto Bob dovrà inglobare la rete neurale in un involucro che risulti valido secondo le caratteristiche descritte nel paragrafo precedente, con $ L $ e $ M_i $ fissati; in altri termini, Bob dovrà espandere la rete aggiungendo in essa un determinato numero di nodi fittizi per ogni specifico livello. Inoltre, Bob dovrà accordarsi con Alice su alcuni valori: il parametro di quantizzazione $ Q $ (di cui si rimanda la spiegazione alla sezione \ref{sec:wwni}) e un parametro $ s $ da usare con il cifrario. Inoltre, Alice dovrà generare una coppia di chiavi pubblica/privata (inviando la prima a Bob), mentre Bob dovrà permutare per ogni singolo livello le posizioni dei nodi componenti la rete neurale.\\
Si osservi che nel protocollo seguente tutti i neuroni (reali e fittizi) vengono trattati allo stesso modo, dato che non vi sono effettivamente differenze (almeno dal punto di vista di Alice). Ciò nonostante, bisogna ricordare che i valori di uscita dei nodi fittizi non saranno in realtà utilizzati se non come valori di ingresso per altri nodi fittizi. Inoltre, si suppone che a seguito dell'occultamento della rete Bob sia comunque sempre in grado di generare il vettore $ \bar{c}_j $ contenente i valori di ingresso per ogni singolo neurone, ovvero a partire da un dato neurone $ k $ Bob sarà sempre in grado di ricostruire il vettore $ \bar{c}_j $ contenente i nodi che presentano collegamenti in uscita diretti al neurone $ k $ in questione.\\
Il vettore dei valori di ingresso fornito da Alice sarà chiamato $ \bar{c} $, mentre il vettore dei pesi sarà detto $ \bar{w}_j^{(i)} $ dove sia $ i = 1,\; \ldots,\; L $ e $ j = 1,\; \ldots,\; M_i $.
\begin{itemize}
\item Per ogni $ i = 1,\; \ldots,\; L $ e per ogni $ j = 1,\; \ldots,\; M_i $, ovvero per ogni nodo intermedio, vengono effettuati i passi sotto elencati.
\begin{itemize}
\item Bob calcola il valore $ d = E(a) $, come spiegato in sezione \ref{subsec:cip}, che risulta essere (una volta in chiaro) la somma pesata dei valori in ingresso al nodo
\item Bob calcola in maniera casuale $ t_j \in \lbrace-1, 1\rbrace $, se $ t_j = -1 $ allora viene calcolato $ d = d^{-1} $
\item Bob invia ad Alice il valore $ d $, che sarà decifrato ottenendo il valore $ a $, elaborato secondo una determinata funzione $ g $ ottenendo $ g(a) $ e quindi cifrato nuovamente nella forma $ z = E(g(a)) $ per essere restituito al mittente
\item Se in precedenza era stato calcolato $ t_j = -1 $, allora viene posto $ z = E(1)z^{-1} $
\end{itemize}
\item Per ogni $ k = 1,\; \ldots,\; O $, con $ O $ numero di neuroni di uscita, vengono effettuati i passi sotto elencati.
\begin{itemize}
\item Bob computa il valore $ d = E(a) $, come discusso in sezione \ref{subsec:cip}
\item Bob invia il valore $ d $ ad Alice
\item Alice decifra $ d $ ottenendo il valore $ a $ e calcola localmente il risultato $ g(a) $, ricavando così il valore del determinato nodo di uscita, dove sia $ g $ la funzione di attivazione associata allo specifico nodo
\end{itemize}
\end{itemize}

\section{Possibili applicazioni}
Il protocollo proposto è interessante se inquadrato all'interno di determinate situazioni in cui un suo utilizzo potrebbe, effettivamente, riservare un grado di sicurezza tanto a chi sfrutta il servizio quanto a chi lo offre.\\
Per fare un esempio, si pensi allo scenario in cui un noto ospedale decida di investire nella creazione, addestramento e quindi offerta di reti neurali in grado di classificare un paziente a partire da determinati sintomi (sottomessi come ingressi del sistema). Ovviamente, dal punto di vista dell'ospedale c'è un forte interesse nel proteggere il proprio investimento in quanto si suppone siano spesi soldi e denaro per ottenere il prodotto finale. L'aspetto più importante però è il punto di vista dell'utente del servizio: quest'ultimo, infatti, potrebbe non voler mettere a conoscenza di nessuno i sintomi che lo hanno spinto ad usufruire del servizio messo a disposizione dall'ospedale e, plausibilmente, tantomeno vorrà far sapere a chiunque il suo stato di salute. Se ciò non è del tutto chiaro nell'ottica di un normale cittadino, si pensi al caso in cui ad usufruire del servizio siano personaggi noti appartenenti per esempio al mondo della politica. Sapere che uno specifico soggetto che ricopre cariche di uno determinato livello ha o meno una malattia di una certa gravità può influire non poco sull'ambiente che lo circonda.\\
Quello proposto è solo uno dei tanti casi in cui la possibilità di operare in dominio cifrato da parte di una rete neurale si rivela utile per molti aspetti. Basta avere un po' di fantasia per trovare tante altre applicazioni al protocollo descritto. Questa è infatti la logica conseguenza della necessità crescente, al giorno d'oggi, nel conseguire principi di sicurezza sui dati scambiati fra soggetti, che si sposa con una tecnologia già affermata come le reti neurali e la loro ormai nota capacità di classificazione.

\section{Lavorare con valori non interi}\label{sec:wwni}
Un risvolto negativo nell'uso all'interno di un protocollo di un sistema crittografico qualsiasi è dato dal fatto che questo funziona solamente con valori interi di dimensione arbitraria. È necessario quindi un metodo per riuscire ad operare con numeri reali.\\
Prima di tutto è possibile rappresentare in maniera classica i numeri positivi in $ \lbrace 0,\; \ldots,\; \frac{n^s - 1}{2}\rbrace $ e quelli negativi in $ \lbrace \frac{n^s - 1}{2} + 1,\; \ldots,\; n^s - 1\rbrace $, dove sia: $ -1 = n^s - 1 $. Quindi, dato un valore reale $ x \in \mathbb{R} $, è possibile quantizzarlo con un fattore $ Q $ e approssimarlo a $ \tilde{x} = \lfloor\frac{x}{Q}\rfloor \sim \frac{x}{Q} $, valida per quantizzazioni sufficientemente fini.\\
Ovviamente, valgono ancora le proprietà omomorfiche del cifrario, ovvero:
$$ D(E(\tilde{x}_1)\cdot E(\tilde{x}_2)) = \tilde{x}_1 + \tilde{x}_2 \sim \frac{x_1 + x_2}{Q} $$
Questo mette in condizioni Bob di effettuare un numero arbitrario di somme in dominio cifrato. Inoltre, anche la seconda proprietà è ancora valida, sebbene abbia un rovescio della medaglia da non trascurare. Infatti:
$$ D(E(\tilde{x})^{\tilde{a}}) = \tilde{a}\cdot\tilde{x} \sim \frac{a\cdot x_2}{Q^2} $$
La presenza del fattore $ Q^2 $ comporta che da un lato la dimensione dei numeri cifrati cresca in maniera esponenziale con il numero delle moltiplicazioni effettuate, mentre dall'altro lato Bob deve rivelare ad Alice il numero di moltiplicazioni così che possa compensare la presenza del fattore $ Q^2 $. Fortunatamente, nel primo caso il cifrario sopperisce al problema grazie alla possibilità di incrementare il parametro $ s $ per poter cifrare numeri più grandi. Nel secondo caso, bisogna osservare che nel protocollo è effettuata una sola moltiplicazione per ogni elemento cifrato e quindi non ci sono perdite sulla sicurezza in quanto Bob non deve rivelare a priori niente ad Alice (anch'essa sa già il numero effettivo di moltiplicazioni effettuate).\\
La soluzione al primo problema consiste nello scegliere il parametro $ s $ in modo che il valore contenuto nel testo cifrato dopo la computazione risulti minore di $ n^s $. Posto $ X $ il limite superiore della norma relativa al vettore di valori in ingresso fornito da Alice e sia $ W $ il limite superiore della norma relativa al vettore dei pesi sui collegamenti nella rete neurale, ogni prodotto scalare calcolato all'interno del protocollo è limitato da $\vert x\vert\vert w\vert \cos{\hat{xw}} \leq XW $. Dato un modulo $ n $ sufficientemente grande per scopi di sicurezza, è possibile selezionare un parametro $ s $ così che:
$$ s \geq \lceil \log_n{\frac{2XW}{Q^2}}\rceil $$
Dove il 2 è dovuto alla presenza di valori sia negativi che positivi. Così facendo, si riesce ad ottenere (seppure con qualche limitazione) un cifrario capace di operare con numeri reali adeguatamente quantizzati e quindi riportati in un intervallo di interi positivi.

Ovviamente, la possibilità di trattare i numeri reali all'interno del protocollo si ripercuote su chi propone la rete neurale in termini di scelta del corretto valore utilizzato per quantizzare tali numeri. Infatti, se da un lato un valore di quantizzazione troppo piccolo rischia di trascurare alcune cifre decimali e falsare il risultato, dall'altro lato un valore di quantizzazione troppo grande appesantisce la computazione e porta ad un accrescimento della complessità.\\
Pertanto, bisogna porre molta attenzione alla scelta del fattore di quantizzazione e assicurarsi che esso non influisca né sul risultato né sul tempo necessario per conseguirlo, ma piuttosto rappresenti un giusto compromesso in grado di sposare le esigenze degli utenti con la loro pazienza.
